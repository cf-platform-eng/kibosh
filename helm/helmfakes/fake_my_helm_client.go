// Code generated by counterfeiter. DO NOT EDIT.
package helmfakes

import (
	"sync"

	"github.com/cf-platform-eng/kibosh/helm"
	helmstaller "k8s.io/helm/cmd/helm/installer"
	helmpkg "k8s.io/helm/pkg/helm"
	"k8s.io/helm/pkg/proto/hapi/chart"
	rls "k8s.io/helm/pkg/proto/hapi/services"
)

type FakeMyHelmClient struct {
	ListReleasesStub        func(opts ...helmpkg.ReleaseListOption) (*rls.ListReleasesResponse, error)
	listReleasesMutex       sync.RWMutex
	listReleasesArgsForCall []struct {
		opts []helmpkg.ReleaseListOption
	}
	listReleasesReturns struct {
		result1 *rls.ListReleasesResponse
		result2 error
	}
	listReleasesReturnsOnCall map[int]struct {
		result1 *rls.ListReleasesResponse
		result2 error
	}
	InstallReleaseStub        func(chStr, namespace string, opts ...helmpkg.InstallOption) (*rls.InstallReleaseResponse, error)
	installReleaseMutex       sync.RWMutex
	installReleaseArgsForCall []struct {
		chStr     string
		namespace string
		opts      []helmpkg.InstallOption
	}
	installReleaseReturns struct {
		result1 *rls.InstallReleaseResponse
		result2 error
	}
	installReleaseReturnsOnCall map[int]struct {
		result1 *rls.InstallReleaseResponse
		result2 error
	}
	InstallReleaseFromChartStub        func(chart *chart.Chart, namespace string, opts ...helmpkg.InstallOption) (*rls.InstallReleaseResponse, error)
	installReleaseFromChartMutex       sync.RWMutex
	installReleaseFromChartArgsForCall []struct {
		chart     *chart.Chart
		namespace string
		opts      []helmpkg.InstallOption
	}
	installReleaseFromChartReturns struct {
		result1 *rls.InstallReleaseResponse
		result2 error
	}
	installReleaseFromChartReturnsOnCall map[int]struct {
		result1 *rls.InstallReleaseResponse
		result2 error
	}
	DeleteReleaseStub        func(rlsName string, opts ...helmpkg.DeleteOption) (*rls.UninstallReleaseResponse, error)
	deleteReleaseMutex       sync.RWMutex
	deleteReleaseArgsForCall []struct {
		rlsName string
		opts    []helmpkg.DeleteOption
	}
	deleteReleaseReturns struct {
		result1 *rls.UninstallReleaseResponse
		result2 error
	}
	deleteReleaseReturnsOnCall map[int]struct {
		result1 *rls.UninstallReleaseResponse
		result2 error
	}
	ReleaseStatusStub        func(rlsName string, opts ...helmpkg.StatusOption) (*rls.GetReleaseStatusResponse, error)
	releaseStatusMutex       sync.RWMutex
	releaseStatusArgsForCall []struct {
		rlsName string
		opts    []helmpkg.StatusOption
	}
	releaseStatusReturns struct {
		result1 *rls.GetReleaseStatusResponse
		result2 error
	}
	releaseStatusReturnsOnCall map[int]struct {
		result1 *rls.GetReleaseStatusResponse
		result2 error
	}
	UpdateReleaseStub        func(rlsName, chStr string, opts ...helmpkg.UpdateOption) (*rls.UpdateReleaseResponse, error)
	updateReleaseMutex       sync.RWMutex
	updateReleaseArgsForCall []struct {
		rlsName string
		chStr   string
		opts    []helmpkg.UpdateOption
	}
	updateReleaseReturns struct {
		result1 *rls.UpdateReleaseResponse
		result2 error
	}
	updateReleaseReturnsOnCall map[int]struct {
		result1 *rls.UpdateReleaseResponse
		result2 error
	}
	UpdateReleaseFromChartStub        func(rlsName string, chart *chart.Chart, opts ...helmpkg.UpdateOption) (*rls.UpdateReleaseResponse, error)
	updateReleaseFromChartMutex       sync.RWMutex
	updateReleaseFromChartArgsForCall []struct {
		rlsName string
		chart   *chart.Chart
		opts    []helmpkg.UpdateOption
	}
	updateReleaseFromChartReturns struct {
		result1 *rls.UpdateReleaseResponse
		result2 error
	}
	updateReleaseFromChartReturnsOnCall map[int]struct {
		result1 *rls.UpdateReleaseResponse
		result2 error
	}
	RollbackReleaseStub        func(rlsName string, opts ...helmpkg.RollbackOption) (*rls.RollbackReleaseResponse, error)
	rollbackReleaseMutex       sync.RWMutex
	rollbackReleaseArgsForCall []struct {
		rlsName string
		opts    []helmpkg.RollbackOption
	}
	rollbackReleaseReturns struct {
		result1 *rls.RollbackReleaseResponse
		result2 error
	}
	rollbackReleaseReturnsOnCall map[int]struct {
		result1 *rls.RollbackReleaseResponse
		result2 error
	}
	ReleaseContentStub        func(rlsName string, opts ...helmpkg.ContentOption) (*rls.GetReleaseContentResponse, error)
	releaseContentMutex       sync.RWMutex
	releaseContentArgsForCall []struct {
		rlsName string
		opts    []helmpkg.ContentOption
	}
	releaseContentReturns struct {
		result1 *rls.GetReleaseContentResponse
		result2 error
	}
	releaseContentReturnsOnCall map[int]struct {
		result1 *rls.GetReleaseContentResponse
		result2 error
	}
	ReleaseHistoryStub        func(rlsName string, opts ...helmpkg.HistoryOption) (*rls.GetHistoryResponse, error)
	releaseHistoryMutex       sync.RWMutex
	releaseHistoryArgsForCall []struct {
		rlsName string
		opts    []helmpkg.HistoryOption
	}
	releaseHistoryReturns struct {
		result1 *rls.GetHistoryResponse
		result2 error
	}
	releaseHistoryReturnsOnCall map[int]struct {
		result1 *rls.GetHistoryResponse
		result2 error
	}
	GetVersionStub        func(opts ...helmpkg.VersionOption) (*rls.GetVersionResponse, error)
	getVersionMutex       sync.RWMutex
	getVersionArgsForCall []struct {
		opts []helmpkg.VersionOption
	}
	getVersionReturns struct {
		result1 *rls.GetVersionResponse
		result2 error
	}
	getVersionReturnsOnCall map[int]struct {
		result1 *rls.GetVersionResponse
		result2 error
	}
	RunReleaseTestStub        func(rlsName string, opts ...helmpkg.ReleaseTestOption) (<-chan *rls.TestReleaseResponse, <-chan error)
	runReleaseTestMutex       sync.RWMutex
	runReleaseTestArgsForCall []struct {
		rlsName string
		opts    []helmpkg.ReleaseTestOption
	}
	runReleaseTestReturns struct {
		result1 <-chan *rls.TestReleaseResponse
		result2 <-chan error
	}
	runReleaseTestReturnsOnCall map[int]struct {
		result1 <-chan *rls.TestReleaseResponse
		result2 <-chan error
	}
	InstallStub        func(*helmstaller.Options) error
	installMutex       sync.RWMutex
	installArgsForCall []struct {
		arg1 *helmstaller.Options
	}
	installReturns struct {
		result1 error
	}
	installReturnsOnCall map[int]struct {
		result1 error
	}
	UpgradeStub        func(*helmstaller.Options) error
	upgradeMutex       sync.RWMutex
	upgradeArgsForCall []struct {
		arg1 *helmstaller.Options
	}
	upgradeReturns struct {
		result1 error
	}
	upgradeReturnsOnCall map[int]struct {
		result1 error
	}
	InstallReleaseFromDirStub        func(string, string, ...helmpkg.InstallOption) (*rls.InstallReleaseResponse, error)
	installReleaseFromDirMutex       sync.RWMutex
	installReleaseFromDirArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []helmpkg.InstallOption
	}
	installReleaseFromDirReturns struct {
		result1 *rls.InstallReleaseResponse
		result2 error
	}
	installReleaseFromDirReturnsOnCall map[int]struct {
		result1 *rls.InstallReleaseResponse
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeMyHelmClient) ListReleases(opts ...helmpkg.ReleaseListOption) (*rls.ListReleasesResponse, error) {
	fake.listReleasesMutex.Lock()
	ret, specificReturn := fake.listReleasesReturnsOnCall[len(fake.listReleasesArgsForCall)]
	fake.listReleasesArgsForCall = append(fake.listReleasesArgsForCall, struct {
		opts []helmpkg.ReleaseListOption
	}{opts})
	fake.recordInvocation("ListReleases", []interface{}{opts})
	fake.listReleasesMutex.Unlock()
	if fake.ListReleasesStub != nil {
		return fake.ListReleasesStub(opts...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.listReleasesReturns.result1, fake.listReleasesReturns.result2
}

func (fake *FakeMyHelmClient) ListReleasesCallCount() int {
	fake.listReleasesMutex.RLock()
	defer fake.listReleasesMutex.RUnlock()
	return len(fake.listReleasesArgsForCall)
}

func (fake *FakeMyHelmClient) ListReleasesArgsForCall(i int) []helmpkg.ReleaseListOption {
	fake.listReleasesMutex.RLock()
	defer fake.listReleasesMutex.RUnlock()
	return fake.listReleasesArgsForCall[i].opts
}

func (fake *FakeMyHelmClient) ListReleasesReturns(result1 *rls.ListReleasesResponse, result2 error) {
	fake.ListReleasesStub = nil
	fake.listReleasesReturns = struct {
		result1 *rls.ListReleasesResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) ListReleasesReturnsOnCall(i int, result1 *rls.ListReleasesResponse, result2 error) {
	fake.ListReleasesStub = nil
	if fake.listReleasesReturnsOnCall == nil {
		fake.listReleasesReturnsOnCall = make(map[int]struct {
			result1 *rls.ListReleasesResponse
			result2 error
		})
	}
	fake.listReleasesReturnsOnCall[i] = struct {
		result1 *rls.ListReleasesResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) InstallRelease(chStr string, namespace string, opts ...helmpkg.InstallOption) (*rls.InstallReleaseResponse, error) {
	fake.installReleaseMutex.Lock()
	ret, specificReturn := fake.installReleaseReturnsOnCall[len(fake.installReleaseArgsForCall)]
	fake.installReleaseArgsForCall = append(fake.installReleaseArgsForCall, struct {
		chStr     string
		namespace string
		opts      []helmpkg.InstallOption
	}{chStr, namespace, opts})
	fake.recordInvocation("InstallRelease", []interface{}{chStr, namespace, opts})
	fake.installReleaseMutex.Unlock()
	if fake.InstallReleaseStub != nil {
		return fake.InstallReleaseStub(chStr, namespace, opts...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.installReleaseReturns.result1, fake.installReleaseReturns.result2
}

func (fake *FakeMyHelmClient) InstallReleaseCallCount() int {
	fake.installReleaseMutex.RLock()
	defer fake.installReleaseMutex.RUnlock()
	return len(fake.installReleaseArgsForCall)
}

func (fake *FakeMyHelmClient) InstallReleaseArgsForCall(i int) (string, string, []helmpkg.InstallOption) {
	fake.installReleaseMutex.RLock()
	defer fake.installReleaseMutex.RUnlock()
	return fake.installReleaseArgsForCall[i].chStr, fake.installReleaseArgsForCall[i].namespace, fake.installReleaseArgsForCall[i].opts
}

func (fake *FakeMyHelmClient) InstallReleaseReturns(result1 *rls.InstallReleaseResponse, result2 error) {
	fake.InstallReleaseStub = nil
	fake.installReleaseReturns = struct {
		result1 *rls.InstallReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) InstallReleaseReturnsOnCall(i int, result1 *rls.InstallReleaseResponse, result2 error) {
	fake.InstallReleaseStub = nil
	if fake.installReleaseReturnsOnCall == nil {
		fake.installReleaseReturnsOnCall = make(map[int]struct {
			result1 *rls.InstallReleaseResponse
			result2 error
		})
	}
	fake.installReleaseReturnsOnCall[i] = struct {
		result1 *rls.InstallReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) InstallReleaseFromChart(chart *chart.Chart, namespace string, opts ...helmpkg.InstallOption) (*rls.InstallReleaseResponse, error) {
	panic("counterfeiter generation fail")
}

func (fake *FakeMyHelmClient) InstallReleaseFromChartCallCount() int {
	fake.installReleaseFromChartMutex.RLock()
	defer fake.installReleaseFromChartMutex.RUnlock()
	return len(fake.installReleaseFromChartArgsForCall)
}

func (fake *FakeMyHelmClient) InstallReleaseFromChartArgsForCall(i int) (*chart.Chart, string, []helmpkg.InstallOption) {
	fake.installReleaseFromChartMutex.RLock()
	defer fake.installReleaseFromChartMutex.RUnlock()
	return fake.installReleaseFromChartArgsForCall[i].chart, fake.installReleaseFromChartArgsForCall[i].namespace, fake.installReleaseFromChartArgsForCall[i].opts
}

func (fake *FakeMyHelmClient) InstallReleaseFromChartReturns(result1 *rls.InstallReleaseResponse, result2 error) {
	fake.InstallReleaseFromChartStub = nil
	fake.installReleaseFromChartReturns = struct {
		result1 *rls.InstallReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) InstallReleaseFromChartReturnsOnCall(i int, result1 *rls.InstallReleaseResponse, result2 error) {
	fake.InstallReleaseFromChartStub = nil
	if fake.installReleaseFromChartReturnsOnCall == nil {
		fake.installReleaseFromChartReturnsOnCall = make(map[int]struct {
			result1 *rls.InstallReleaseResponse
			result2 error
		})
	}
	fake.installReleaseFromChartReturnsOnCall[i] = struct {
		result1 *rls.InstallReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) DeleteRelease(rlsName string, opts ...helmpkg.DeleteOption) (*rls.UninstallReleaseResponse, error) {
	fake.deleteReleaseMutex.Lock()
	ret, specificReturn := fake.deleteReleaseReturnsOnCall[len(fake.deleteReleaseArgsForCall)]
	fake.deleteReleaseArgsForCall = append(fake.deleteReleaseArgsForCall, struct {
		rlsName string
		opts    []helmpkg.DeleteOption
	}{rlsName, opts})
	fake.recordInvocation("DeleteRelease", []interface{}{rlsName, opts})
	fake.deleteReleaseMutex.Unlock()
	if fake.DeleteReleaseStub != nil {
		return fake.DeleteReleaseStub(rlsName, opts...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.deleteReleaseReturns.result1, fake.deleteReleaseReturns.result2
}

func (fake *FakeMyHelmClient) DeleteReleaseCallCount() int {
	fake.deleteReleaseMutex.RLock()
	defer fake.deleteReleaseMutex.RUnlock()
	return len(fake.deleteReleaseArgsForCall)
}

func (fake *FakeMyHelmClient) DeleteReleaseArgsForCall(i int) (string, []helmpkg.DeleteOption) {
	fake.deleteReleaseMutex.RLock()
	defer fake.deleteReleaseMutex.RUnlock()
	return fake.deleteReleaseArgsForCall[i].rlsName, fake.deleteReleaseArgsForCall[i].opts
}

func (fake *FakeMyHelmClient) DeleteReleaseReturns(result1 *rls.UninstallReleaseResponse, result2 error) {
	fake.DeleteReleaseStub = nil
	fake.deleteReleaseReturns = struct {
		result1 *rls.UninstallReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) DeleteReleaseReturnsOnCall(i int, result1 *rls.UninstallReleaseResponse, result2 error) {
	fake.DeleteReleaseStub = nil
	if fake.deleteReleaseReturnsOnCall == nil {
		fake.deleteReleaseReturnsOnCall = make(map[int]struct {
			result1 *rls.UninstallReleaseResponse
			result2 error
		})
	}
	fake.deleteReleaseReturnsOnCall[i] = struct {
		result1 *rls.UninstallReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) ReleaseStatus(rlsName string, opts ...helmpkg.StatusOption) (*rls.GetReleaseStatusResponse, error) {
	fake.releaseStatusMutex.Lock()
	ret, specificReturn := fake.releaseStatusReturnsOnCall[len(fake.releaseStatusArgsForCall)]
	fake.releaseStatusArgsForCall = append(fake.releaseStatusArgsForCall, struct {
		rlsName string
		opts    []helmpkg.StatusOption
	}{rlsName, opts})
	fake.recordInvocation("ReleaseStatus", []interface{}{rlsName, opts})
	fake.releaseStatusMutex.Unlock()
	if fake.ReleaseStatusStub != nil {
		return fake.ReleaseStatusStub(rlsName, opts...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.releaseStatusReturns.result1, fake.releaseStatusReturns.result2
}

func (fake *FakeMyHelmClient) ReleaseStatusCallCount() int {
	fake.releaseStatusMutex.RLock()
	defer fake.releaseStatusMutex.RUnlock()
	return len(fake.releaseStatusArgsForCall)
}

func (fake *FakeMyHelmClient) ReleaseStatusArgsForCall(i int) (string, []helmpkg.StatusOption) {
	fake.releaseStatusMutex.RLock()
	defer fake.releaseStatusMutex.RUnlock()
	return fake.releaseStatusArgsForCall[i].rlsName, fake.releaseStatusArgsForCall[i].opts
}

func (fake *FakeMyHelmClient) ReleaseStatusReturns(result1 *rls.GetReleaseStatusResponse, result2 error) {
	fake.ReleaseStatusStub = nil
	fake.releaseStatusReturns = struct {
		result1 *rls.GetReleaseStatusResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) ReleaseStatusReturnsOnCall(i int, result1 *rls.GetReleaseStatusResponse, result2 error) {
	fake.ReleaseStatusStub = nil
	if fake.releaseStatusReturnsOnCall == nil {
		fake.releaseStatusReturnsOnCall = make(map[int]struct {
			result1 *rls.GetReleaseStatusResponse
			result2 error
		})
	}
	fake.releaseStatusReturnsOnCall[i] = struct {
		result1 *rls.GetReleaseStatusResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) UpdateRelease(rlsName string, chStr string, opts ...helmpkg.UpdateOption) (*rls.UpdateReleaseResponse, error) {
	fake.updateReleaseMutex.Lock()
	ret, specificReturn := fake.updateReleaseReturnsOnCall[len(fake.updateReleaseArgsForCall)]
	fake.updateReleaseArgsForCall = append(fake.updateReleaseArgsForCall, struct {
		rlsName string
		chStr   string
		opts    []helmpkg.UpdateOption
	}{rlsName, chStr, opts})
	fake.recordInvocation("UpdateRelease", []interface{}{rlsName, chStr, opts})
	fake.updateReleaseMutex.Unlock()
	if fake.UpdateReleaseStub != nil {
		return fake.UpdateReleaseStub(rlsName, chStr, opts...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.updateReleaseReturns.result1, fake.updateReleaseReturns.result2
}

func (fake *FakeMyHelmClient) UpdateReleaseCallCount() int {
	fake.updateReleaseMutex.RLock()
	defer fake.updateReleaseMutex.RUnlock()
	return len(fake.updateReleaseArgsForCall)
}

func (fake *FakeMyHelmClient) UpdateReleaseArgsForCall(i int) (string, string, []helmpkg.UpdateOption) {
	fake.updateReleaseMutex.RLock()
	defer fake.updateReleaseMutex.RUnlock()
	return fake.updateReleaseArgsForCall[i].rlsName, fake.updateReleaseArgsForCall[i].chStr, fake.updateReleaseArgsForCall[i].opts
}

func (fake *FakeMyHelmClient) UpdateReleaseReturns(result1 *rls.UpdateReleaseResponse, result2 error) {
	fake.UpdateReleaseStub = nil
	fake.updateReleaseReturns = struct {
		result1 *rls.UpdateReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) UpdateReleaseReturnsOnCall(i int, result1 *rls.UpdateReleaseResponse, result2 error) {
	fake.UpdateReleaseStub = nil
	if fake.updateReleaseReturnsOnCall == nil {
		fake.updateReleaseReturnsOnCall = make(map[int]struct {
			result1 *rls.UpdateReleaseResponse
			result2 error
		})
	}
	fake.updateReleaseReturnsOnCall[i] = struct {
		result1 *rls.UpdateReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) UpdateReleaseFromChart(rlsName string, chart *chart.Chart, opts ...helmpkg.UpdateOption) (*rls.UpdateReleaseResponse, error) {
	panic("counterfeiter generation fail")
}

func (fake *FakeMyHelmClient) UpdateReleaseFromChartCallCount() int {
	fake.updateReleaseFromChartMutex.RLock()
	defer fake.updateReleaseFromChartMutex.RUnlock()
	return len(fake.updateReleaseFromChartArgsForCall)
}

func (fake *FakeMyHelmClient) UpdateReleaseFromChartArgsForCall(i int) (string, *chart.Chart, []helmpkg.UpdateOption) {
	fake.updateReleaseFromChartMutex.RLock()
	defer fake.updateReleaseFromChartMutex.RUnlock()
	return fake.updateReleaseFromChartArgsForCall[i].rlsName, fake.updateReleaseFromChartArgsForCall[i].chart, fake.updateReleaseFromChartArgsForCall[i].opts
}

func (fake *FakeMyHelmClient) UpdateReleaseFromChartReturns(result1 *rls.UpdateReleaseResponse, result2 error) {
	fake.UpdateReleaseFromChartStub = nil
	fake.updateReleaseFromChartReturns = struct {
		result1 *rls.UpdateReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) UpdateReleaseFromChartReturnsOnCall(i int, result1 *rls.UpdateReleaseResponse, result2 error) {
	fake.UpdateReleaseFromChartStub = nil
	if fake.updateReleaseFromChartReturnsOnCall == nil {
		fake.updateReleaseFromChartReturnsOnCall = make(map[int]struct {
			result1 *rls.UpdateReleaseResponse
			result2 error
		})
	}
	fake.updateReleaseFromChartReturnsOnCall[i] = struct {
		result1 *rls.UpdateReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) RollbackRelease(rlsName string, opts ...helmpkg.RollbackOption) (*rls.RollbackReleaseResponse, error) {
	fake.rollbackReleaseMutex.Lock()
	ret, specificReturn := fake.rollbackReleaseReturnsOnCall[len(fake.rollbackReleaseArgsForCall)]
	fake.rollbackReleaseArgsForCall = append(fake.rollbackReleaseArgsForCall, struct {
		rlsName string
		opts    []helmpkg.RollbackOption
	}{rlsName, opts})
	fake.recordInvocation("RollbackRelease", []interface{}{rlsName, opts})
	fake.rollbackReleaseMutex.Unlock()
	if fake.RollbackReleaseStub != nil {
		return fake.RollbackReleaseStub(rlsName, opts...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.rollbackReleaseReturns.result1, fake.rollbackReleaseReturns.result2
}

func (fake *FakeMyHelmClient) RollbackReleaseCallCount() int {
	fake.rollbackReleaseMutex.RLock()
	defer fake.rollbackReleaseMutex.RUnlock()
	return len(fake.rollbackReleaseArgsForCall)
}

func (fake *FakeMyHelmClient) RollbackReleaseArgsForCall(i int) (string, []helmpkg.RollbackOption) {
	fake.rollbackReleaseMutex.RLock()
	defer fake.rollbackReleaseMutex.RUnlock()
	return fake.rollbackReleaseArgsForCall[i].rlsName, fake.rollbackReleaseArgsForCall[i].opts
}

func (fake *FakeMyHelmClient) RollbackReleaseReturns(result1 *rls.RollbackReleaseResponse, result2 error) {
	fake.RollbackReleaseStub = nil
	fake.rollbackReleaseReturns = struct {
		result1 *rls.RollbackReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) RollbackReleaseReturnsOnCall(i int, result1 *rls.RollbackReleaseResponse, result2 error) {
	fake.RollbackReleaseStub = nil
	if fake.rollbackReleaseReturnsOnCall == nil {
		fake.rollbackReleaseReturnsOnCall = make(map[int]struct {
			result1 *rls.RollbackReleaseResponse
			result2 error
		})
	}
	fake.rollbackReleaseReturnsOnCall[i] = struct {
		result1 *rls.RollbackReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) ReleaseContent(rlsName string, opts ...helmpkg.ContentOption) (*rls.GetReleaseContentResponse, error) {
	fake.releaseContentMutex.Lock()
	ret, specificReturn := fake.releaseContentReturnsOnCall[len(fake.releaseContentArgsForCall)]
	fake.releaseContentArgsForCall = append(fake.releaseContentArgsForCall, struct {
		rlsName string
		opts    []helmpkg.ContentOption
	}{rlsName, opts})
	fake.recordInvocation("ReleaseContent", []interface{}{rlsName, opts})
	fake.releaseContentMutex.Unlock()
	if fake.ReleaseContentStub != nil {
		return fake.ReleaseContentStub(rlsName, opts...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.releaseContentReturns.result1, fake.releaseContentReturns.result2
}

func (fake *FakeMyHelmClient) ReleaseContentCallCount() int {
	fake.releaseContentMutex.RLock()
	defer fake.releaseContentMutex.RUnlock()
	return len(fake.releaseContentArgsForCall)
}

func (fake *FakeMyHelmClient) ReleaseContentArgsForCall(i int) (string, []helmpkg.ContentOption) {
	fake.releaseContentMutex.RLock()
	defer fake.releaseContentMutex.RUnlock()
	return fake.releaseContentArgsForCall[i].rlsName, fake.releaseContentArgsForCall[i].opts
}

func (fake *FakeMyHelmClient) ReleaseContentReturns(result1 *rls.GetReleaseContentResponse, result2 error) {
	fake.ReleaseContentStub = nil
	fake.releaseContentReturns = struct {
		result1 *rls.GetReleaseContentResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) ReleaseContentReturnsOnCall(i int, result1 *rls.GetReleaseContentResponse, result2 error) {
	fake.ReleaseContentStub = nil
	if fake.releaseContentReturnsOnCall == nil {
		fake.releaseContentReturnsOnCall = make(map[int]struct {
			result1 *rls.GetReleaseContentResponse
			result2 error
		})
	}
	fake.releaseContentReturnsOnCall[i] = struct {
		result1 *rls.GetReleaseContentResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) ReleaseHistory(rlsName string, opts ...helmpkg.HistoryOption) (*rls.GetHistoryResponse, error) {
	fake.releaseHistoryMutex.Lock()
	ret, specificReturn := fake.releaseHistoryReturnsOnCall[len(fake.releaseHistoryArgsForCall)]
	fake.releaseHistoryArgsForCall = append(fake.releaseHistoryArgsForCall, struct {
		rlsName string
		opts    []helmpkg.HistoryOption
	}{rlsName, opts})
	fake.recordInvocation("ReleaseHistory", []interface{}{rlsName, opts})
	fake.releaseHistoryMutex.Unlock()
	if fake.ReleaseHistoryStub != nil {
		return fake.ReleaseHistoryStub(rlsName, opts...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.releaseHistoryReturns.result1, fake.releaseHistoryReturns.result2
}

func (fake *FakeMyHelmClient) ReleaseHistoryCallCount() int {
	fake.releaseHistoryMutex.RLock()
	defer fake.releaseHistoryMutex.RUnlock()
	return len(fake.releaseHistoryArgsForCall)
}

func (fake *FakeMyHelmClient) ReleaseHistoryArgsForCall(i int) (string, []helmpkg.HistoryOption) {
	fake.releaseHistoryMutex.RLock()
	defer fake.releaseHistoryMutex.RUnlock()
	return fake.releaseHistoryArgsForCall[i].rlsName, fake.releaseHistoryArgsForCall[i].opts
}

func (fake *FakeMyHelmClient) ReleaseHistoryReturns(result1 *rls.GetHistoryResponse, result2 error) {
	fake.ReleaseHistoryStub = nil
	fake.releaseHistoryReturns = struct {
		result1 *rls.GetHistoryResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) ReleaseHistoryReturnsOnCall(i int, result1 *rls.GetHistoryResponse, result2 error) {
	fake.ReleaseHistoryStub = nil
	if fake.releaseHistoryReturnsOnCall == nil {
		fake.releaseHistoryReturnsOnCall = make(map[int]struct {
			result1 *rls.GetHistoryResponse
			result2 error
		})
	}
	fake.releaseHistoryReturnsOnCall[i] = struct {
		result1 *rls.GetHistoryResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) GetVersion(opts ...helmpkg.VersionOption) (*rls.GetVersionResponse, error) {
	fake.getVersionMutex.Lock()
	ret, specificReturn := fake.getVersionReturnsOnCall[len(fake.getVersionArgsForCall)]
	fake.getVersionArgsForCall = append(fake.getVersionArgsForCall, struct {
		opts []helmpkg.VersionOption
	}{opts})
	fake.recordInvocation("GetVersion", []interface{}{opts})
	fake.getVersionMutex.Unlock()
	if fake.GetVersionStub != nil {
		return fake.GetVersionStub(opts...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getVersionReturns.result1, fake.getVersionReturns.result2
}

func (fake *FakeMyHelmClient) GetVersionCallCount() int {
	fake.getVersionMutex.RLock()
	defer fake.getVersionMutex.RUnlock()
	return len(fake.getVersionArgsForCall)
}

func (fake *FakeMyHelmClient) GetVersionArgsForCall(i int) []helmpkg.VersionOption {
	fake.getVersionMutex.RLock()
	defer fake.getVersionMutex.RUnlock()
	return fake.getVersionArgsForCall[i].opts
}

func (fake *FakeMyHelmClient) GetVersionReturns(result1 *rls.GetVersionResponse, result2 error) {
	fake.GetVersionStub = nil
	fake.getVersionReturns = struct {
		result1 *rls.GetVersionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) GetVersionReturnsOnCall(i int, result1 *rls.GetVersionResponse, result2 error) {
	fake.GetVersionStub = nil
	if fake.getVersionReturnsOnCall == nil {
		fake.getVersionReturnsOnCall = make(map[int]struct {
			result1 *rls.GetVersionResponse
			result2 error
		})
	}
	fake.getVersionReturnsOnCall[i] = struct {
		result1 *rls.GetVersionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) RunReleaseTest(rlsName string, opts ...helmpkg.ReleaseTestOption) (<-chan *rls.TestReleaseResponse, <-chan error) {
	fake.runReleaseTestMutex.Lock()
	ret, specificReturn := fake.runReleaseTestReturnsOnCall[len(fake.runReleaseTestArgsForCall)]
	fake.runReleaseTestArgsForCall = append(fake.runReleaseTestArgsForCall, struct {
		rlsName string
		opts    []helmpkg.ReleaseTestOption
	}{rlsName, opts})
	fake.recordInvocation("RunReleaseTest", []interface{}{rlsName, opts})
	fake.runReleaseTestMutex.Unlock()
	if fake.RunReleaseTestStub != nil {
		return fake.RunReleaseTestStub(rlsName, opts...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.runReleaseTestReturns.result1, fake.runReleaseTestReturns.result2
}

func (fake *FakeMyHelmClient) RunReleaseTestCallCount() int {
	fake.runReleaseTestMutex.RLock()
	defer fake.runReleaseTestMutex.RUnlock()
	return len(fake.runReleaseTestArgsForCall)
}

func (fake *FakeMyHelmClient) RunReleaseTestArgsForCall(i int) (string, []helmpkg.ReleaseTestOption) {
	fake.runReleaseTestMutex.RLock()
	defer fake.runReleaseTestMutex.RUnlock()
	return fake.runReleaseTestArgsForCall[i].rlsName, fake.runReleaseTestArgsForCall[i].opts
}

func (fake *FakeMyHelmClient) RunReleaseTestReturns(result1 <-chan *rls.TestReleaseResponse, result2 <-chan error) {
	fake.RunReleaseTestStub = nil
	fake.runReleaseTestReturns = struct {
		result1 <-chan *rls.TestReleaseResponse
		result2 <-chan error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) RunReleaseTestReturnsOnCall(i int, result1 <-chan *rls.TestReleaseResponse, result2 <-chan error) {
	fake.RunReleaseTestStub = nil
	if fake.runReleaseTestReturnsOnCall == nil {
		fake.runReleaseTestReturnsOnCall = make(map[int]struct {
			result1 <-chan *rls.TestReleaseResponse
			result2 <-chan error
		})
	}
	fake.runReleaseTestReturnsOnCall[i] = struct {
		result1 <-chan *rls.TestReleaseResponse
		result2 <-chan error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) Install(arg1 *helmstaller.Options) error {
	fake.installMutex.Lock()
	ret, specificReturn := fake.installReturnsOnCall[len(fake.installArgsForCall)]
	fake.installArgsForCall = append(fake.installArgsForCall, struct {
		arg1 *helmstaller.Options
	}{arg1})
	fake.recordInvocation("Install", []interface{}{arg1})
	fake.installMutex.Unlock()
	if fake.InstallStub != nil {
		return fake.InstallStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.installReturns.result1
}

func (fake *FakeMyHelmClient) InstallCallCount() int {
	fake.installMutex.RLock()
	defer fake.installMutex.RUnlock()
	return len(fake.installArgsForCall)
}

func (fake *FakeMyHelmClient) InstallArgsForCall(i int) *helmstaller.Options {
	fake.installMutex.RLock()
	defer fake.installMutex.RUnlock()
	return fake.installArgsForCall[i].arg1
}

func (fake *FakeMyHelmClient) InstallReturns(result1 error) {
	fake.InstallStub = nil
	fake.installReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMyHelmClient) InstallReturnsOnCall(i int, result1 error) {
	fake.InstallStub = nil
	if fake.installReturnsOnCall == nil {
		fake.installReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.installReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMyHelmClient) Upgrade(arg1 *helmstaller.Options) error {
	fake.upgradeMutex.Lock()
	ret, specificReturn := fake.upgradeReturnsOnCall[len(fake.upgradeArgsForCall)]
	fake.upgradeArgsForCall = append(fake.upgradeArgsForCall, struct {
		arg1 *helmstaller.Options
	}{arg1})
	fake.recordInvocation("Upgrade", []interface{}{arg1})
	fake.upgradeMutex.Unlock()
	if fake.UpgradeStub != nil {
		return fake.UpgradeStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.upgradeReturns.result1
}

func (fake *FakeMyHelmClient) UpgradeCallCount() int {
	fake.upgradeMutex.RLock()
	defer fake.upgradeMutex.RUnlock()
	return len(fake.upgradeArgsForCall)
}

func (fake *FakeMyHelmClient) UpgradeArgsForCall(i int) *helmstaller.Options {
	fake.upgradeMutex.RLock()
	defer fake.upgradeMutex.RUnlock()
	return fake.upgradeArgsForCall[i].arg1
}

func (fake *FakeMyHelmClient) UpgradeReturns(result1 error) {
	fake.UpgradeStub = nil
	fake.upgradeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMyHelmClient) UpgradeReturnsOnCall(i int, result1 error) {
	fake.UpgradeStub = nil
	if fake.upgradeReturnsOnCall == nil {
		fake.upgradeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.upgradeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMyHelmClient) InstallReleaseFromDir(arg1 string, arg2 string, arg3 ...helmpkg.InstallOption) (*rls.InstallReleaseResponse, error) {
	fake.installReleaseFromDirMutex.Lock()
	ret, specificReturn := fake.installReleaseFromDirReturnsOnCall[len(fake.installReleaseFromDirArgsForCall)]
	fake.installReleaseFromDirArgsForCall = append(fake.installReleaseFromDirArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []helmpkg.InstallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("InstallReleaseFromDir", []interface{}{arg1, arg2, arg3})
	fake.installReleaseFromDirMutex.Unlock()
	if fake.InstallReleaseFromDirStub != nil {
		return fake.InstallReleaseFromDirStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.installReleaseFromDirReturns.result1, fake.installReleaseFromDirReturns.result2
}

func (fake *FakeMyHelmClient) InstallReleaseFromDirCallCount() int {
	fake.installReleaseFromDirMutex.RLock()
	defer fake.installReleaseFromDirMutex.RUnlock()
	return len(fake.installReleaseFromDirArgsForCall)
}

func (fake *FakeMyHelmClient) InstallReleaseFromDirArgsForCall(i int) (string, string, []helmpkg.InstallOption) {
	fake.installReleaseFromDirMutex.RLock()
	defer fake.installReleaseFromDirMutex.RUnlock()
	return fake.installReleaseFromDirArgsForCall[i].arg1, fake.installReleaseFromDirArgsForCall[i].arg2, fake.installReleaseFromDirArgsForCall[i].arg3
}

func (fake *FakeMyHelmClient) InstallReleaseFromDirReturns(result1 *rls.InstallReleaseResponse, result2 error) {
	fake.InstallReleaseFromDirStub = nil
	fake.installReleaseFromDirReturns = struct {
		result1 *rls.InstallReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) InstallReleaseFromDirReturnsOnCall(i int, result1 *rls.InstallReleaseResponse, result2 error) {
	fake.InstallReleaseFromDirStub = nil
	if fake.installReleaseFromDirReturnsOnCall == nil {
		fake.installReleaseFromDirReturnsOnCall = make(map[int]struct {
			result1 *rls.InstallReleaseResponse
			result2 error
		})
	}
	fake.installReleaseFromDirReturnsOnCall[i] = struct {
		result1 *rls.InstallReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.listReleasesMutex.RLock()
	defer fake.listReleasesMutex.RUnlock()
	fake.installReleaseMutex.RLock()
	defer fake.installReleaseMutex.RUnlock()
	fake.installReleaseFromChartMutex.RLock()
	defer fake.installReleaseFromChartMutex.RUnlock()
	fake.deleteReleaseMutex.RLock()
	defer fake.deleteReleaseMutex.RUnlock()
	fake.releaseStatusMutex.RLock()
	defer fake.releaseStatusMutex.RUnlock()
	fake.updateReleaseMutex.RLock()
	defer fake.updateReleaseMutex.RUnlock()
	fake.updateReleaseFromChartMutex.RLock()
	defer fake.updateReleaseFromChartMutex.RUnlock()
	fake.rollbackReleaseMutex.RLock()
	defer fake.rollbackReleaseMutex.RUnlock()
	fake.releaseContentMutex.RLock()
	defer fake.releaseContentMutex.RUnlock()
	fake.releaseHistoryMutex.RLock()
	defer fake.releaseHistoryMutex.RUnlock()
	fake.getVersionMutex.RLock()
	defer fake.getVersionMutex.RUnlock()
	fake.runReleaseTestMutex.RLock()
	defer fake.runReleaseTestMutex.RUnlock()
	fake.installMutex.RLock()
	defer fake.installMutex.RUnlock()
	fake.upgradeMutex.RLock()
	defer fake.upgradeMutex.RUnlock()
	fake.installReleaseFromDirMutex.RLock()
	defer fake.installReleaseFromDirMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeMyHelmClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ helm.MyHelmClient = new(FakeMyHelmClient)

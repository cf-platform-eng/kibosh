// Code generated by counterfeiter. DO NOT EDIT.
package k8sfakes

import (
	"sync"

	"github.com/cf-platform-eng/kibosh/pkg/k8s"
	v1 "k8s.io/api/core/v1"
	v1beta1a "k8s.io/api/extensions/v1beta1"
	"k8s.io/api/rbac/v1beta1"
	v1a "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
)

type FakeClusterDelegate struct {
	CreateClusterRoleBindingStub        func(*v1beta1.ClusterRoleBinding) (*v1beta1.ClusterRoleBinding, error)
	createClusterRoleBindingMutex       sync.RWMutex
	createClusterRoleBindingArgsForCall []struct {
		arg1 *v1beta1.ClusterRoleBinding
	}
	createClusterRoleBindingReturns struct {
		result1 *v1beta1.ClusterRoleBinding
		result2 error
	}
	createClusterRoleBindingReturnsOnCall map[int]struct {
		result1 *v1beta1.ClusterRoleBinding
		result2 error
	}
	CreateNamespaceStub        func(*v1.Namespace) (*v1.Namespace, error)
	createNamespaceMutex       sync.RWMutex
	createNamespaceArgsForCall []struct {
		arg1 *v1.Namespace
	}
	createNamespaceReturns struct {
		result1 *v1.Namespace
		result2 error
	}
	createNamespaceReturnsOnCall map[int]struct {
		result1 *v1.Namespace
		result2 error
	}
	CreateSecretStub        func(string, *v1.Secret) (*v1.Secret, error)
	createSecretMutex       sync.RWMutex
	createSecretArgsForCall []struct {
		arg1 string
		arg2 *v1.Secret
	}
	createSecretReturns struct {
		result1 *v1.Secret
		result2 error
	}
	createSecretReturnsOnCall map[int]struct {
		result1 *v1.Secret
		result2 error
	}
	CreateServiceAccountStub        func(string, *v1.ServiceAccount) (*v1.ServiceAccount, error)
	createServiceAccountMutex       sync.RWMutex
	createServiceAccountArgsForCall []struct {
		arg1 string
		arg2 *v1.ServiceAccount
	}
	createServiceAccountReturns struct {
		result1 *v1.ServiceAccount
		result2 error
	}
	createServiceAccountReturnsOnCall map[int]struct {
		result1 *v1.ServiceAccount
		result2 error
	}
	DeleteNamespaceStub        func(string, *v1a.DeleteOptions) error
	deleteNamespaceMutex       sync.RWMutex
	deleteNamespaceArgsForCall []struct {
		arg1 string
		arg2 *v1a.DeleteOptions
	}
	deleteNamespaceReturns struct {
		result1 error
	}
	deleteNamespaceReturnsOnCall map[int]struct {
		result1 error
	}
	GetClientStub        func() kubernetes.Interface
	getClientMutex       sync.RWMutex
	getClientArgsForCall []struct {
	}
	getClientReturns struct {
		result1 kubernetes.Interface
	}
	getClientReturnsOnCall map[int]struct {
		result1 kubernetes.Interface
	}
	GetClientConfigStub        func() *rest.Config
	getClientConfigMutex       sync.RWMutex
	getClientConfigArgsForCall []struct {
	}
	getClientConfigReturns struct {
		result1 *rest.Config
	}
	getClientConfigReturnsOnCall map[int]struct {
		result1 *rest.Config
	}
	GetDeploymentStub        func(string, string, v1a.GetOptions) (*v1beta1a.Deployment, error)
	getDeploymentMutex       sync.RWMutex
	getDeploymentArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 v1a.GetOptions
	}
	getDeploymentReturns struct {
		result1 *v1beta1a.Deployment
		result2 error
	}
	getDeploymentReturnsOnCall map[int]struct {
		result1 *v1beta1a.Deployment
		result2 error
	}
	GetNamespaceStub        func(string, *v1a.GetOptions) (*v1.Namespace, error)
	getNamespaceMutex       sync.RWMutex
	getNamespaceArgsForCall []struct {
		arg1 string
		arg2 *v1a.GetOptions
	}
	getNamespaceReturns struct {
		result1 *v1.Namespace
		result2 error
	}
	getNamespaceReturnsOnCall map[int]struct {
		result1 *v1.Namespace
		result2 error
	}
	GetNamespacesStub        func() (*v1.NamespaceList, error)
	getNamespacesMutex       sync.RWMutex
	getNamespacesArgsForCall []struct {
	}
	getNamespacesReturns struct {
		result1 *v1.NamespaceList
		result2 error
	}
	getNamespacesReturnsOnCall map[int]struct {
		result1 *v1.NamespaceList
		result2 error
	}
	GetSecretStub        func(string, string, v1a.GetOptions) (*v1.Secret, error)
	getSecretMutex       sync.RWMutex
	getSecretArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 v1a.GetOptions
	}
	getSecretReturns struct {
		result1 *v1.Secret
		result2 error
	}
	getSecretReturnsOnCall map[int]struct {
		result1 *v1.Secret
		result2 error
	}
	ListClusterRoleBindingsStub        func(v1a.ListOptions) (*v1beta1.ClusterRoleBindingList, error)
	listClusterRoleBindingsMutex       sync.RWMutex
	listClusterRoleBindingsArgsForCall []struct {
		arg1 v1a.ListOptions
	}
	listClusterRoleBindingsReturns struct {
		result1 *v1beta1.ClusterRoleBindingList
		result2 error
	}
	listClusterRoleBindingsReturnsOnCall map[int]struct {
		result1 *v1beta1.ClusterRoleBindingList
		result2 error
	}
	ListDeploymentsStub        func(string, v1a.ListOptions) (*k8s.DeploymentList, error)
	listDeploymentsMutex       sync.RWMutex
	listDeploymentsArgsForCall []struct {
		arg1 string
		arg2 v1a.ListOptions
	}
	listDeploymentsReturns struct {
		result1 *k8s.DeploymentList
		result2 error
	}
	listDeploymentsReturnsOnCall map[int]struct {
		result1 *k8s.DeploymentList
		result2 error
	}
	ListIngressesStub        func(string, v1a.ListOptions) (*v1beta1a.IngressList, error)
	listIngressesMutex       sync.RWMutex
	listIngressesArgsForCall []struct {
		arg1 string
		arg2 v1a.ListOptions
	}
	listIngressesReturns struct {
		result1 *v1beta1a.IngressList
		result2 error
	}
	listIngressesReturnsOnCall map[int]struct {
		result1 *v1beta1a.IngressList
		result2 error
	}
	ListNodesStub        func(v1a.ListOptions) (*v1.NodeList, error)
	listNodesMutex       sync.RWMutex
	listNodesArgsForCall []struct {
		arg1 v1a.ListOptions
	}
	listNodesReturns struct {
		result1 *v1.NodeList
		result2 error
	}
	listNodesReturnsOnCall map[int]struct {
		result1 *v1.NodeList
		result2 error
	}
	ListPersistentVolumesStub        func(string, v1a.ListOptions) (*v1.PersistentVolumeClaimList, error)
	listPersistentVolumesMutex       sync.RWMutex
	listPersistentVolumesArgsForCall []struct {
		arg1 string
		arg2 v1a.ListOptions
	}
	listPersistentVolumesReturns struct {
		result1 *v1.PersistentVolumeClaimList
		result2 error
	}
	listPersistentVolumesReturnsOnCall map[int]struct {
		result1 *v1.PersistentVolumeClaimList
		result2 error
	}
	ListPodsStub        func(string, v1a.ListOptions) (*v1.PodList, error)
	listPodsMutex       sync.RWMutex
	listPodsArgsForCall []struct {
		arg1 string
		arg2 v1a.ListOptions
	}
	listPodsReturns struct {
		result1 *v1.PodList
		result2 error
	}
	listPodsReturnsOnCall map[int]struct {
		result1 *v1.PodList
		result2 error
	}
	ListSecretsStub        func(string, v1a.ListOptions) (*v1.SecretList, error)
	listSecretsMutex       sync.RWMutex
	listSecretsArgsForCall []struct {
		arg1 string
		arg2 v1a.ListOptions
	}
	listSecretsReturns struct {
		result1 *v1.SecretList
		result2 error
	}
	listSecretsReturnsOnCall map[int]struct {
		result1 *v1.SecretList
		result2 error
	}
	ListServiceAccountsStub        func(string, v1a.ListOptions) (*v1.ServiceAccountList, error)
	listServiceAccountsMutex       sync.RWMutex
	listServiceAccountsArgsForCall []struct {
		arg1 string
		arg2 v1a.ListOptions
	}
	listServiceAccountsReturns struct {
		result1 *v1.ServiceAccountList
		result2 error
	}
	listServiceAccountsReturnsOnCall map[int]struct {
		result1 *v1.ServiceAccountList
		result2 error
	}
	ListServicesStub        func(string, v1a.ListOptions) (*v1.ServiceList, error)
	listServicesMutex       sync.RWMutex
	listServicesArgsForCall []struct {
		arg1 string
		arg2 v1a.ListOptions
	}
	listServicesReturns struct {
		result1 *v1.ServiceList
		result2 error
	}
	listServicesReturnsOnCall map[int]struct {
		result1 *v1.ServiceList
		result2 error
	}
	PatchStub        func(string, string, types.PatchType, []byte, ...string) (*v1.ServiceAccount, error)
	patchMutex       sync.RWMutex
	patchArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 types.PatchType
		arg4 []byte
		arg5 []string
	}
	patchReturns struct {
		result1 *v1.ServiceAccount
		result2 error
	}
	patchReturnsOnCall map[int]struct {
		result1 *v1.ServiceAccount
		result2 error
	}
	UpdateSecretStub        func(string, *v1.Secret) (*v1.Secret, error)
	updateSecretMutex       sync.RWMutex
	updateSecretArgsForCall []struct {
		arg1 string
		arg2 *v1.Secret
	}
	updateSecretReturns struct {
		result1 *v1.Secret
		result2 error
	}
	updateSecretReturnsOnCall map[int]struct {
		result1 *v1.Secret
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClusterDelegate) CreateClusterRoleBinding(arg1 *v1beta1.ClusterRoleBinding) (*v1beta1.ClusterRoleBinding, error) {
	fake.createClusterRoleBindingMutex.Lock()
	ret, specificReturn := fake.createClusterRoleBindingReturnsOnCall[len(fake.createClusterRoleBindingArgsForCall)]
	fake.createClusterRoleBindingArgsForCall = append(fake.createClusterRoleBindingArgsForCall, struct {
		arg1 *v1beta1.ClusterRoleBinding
	}{arg1})
	fake.recordInvocation("CreateClusterRoleBinding", []interface{}{arg1})
	fake.createClusterRoleBindingMutex.Unlock()
	if fake.CreateClusterRoleBindingStub != nil {
		return fake.CreateClusterRoleBindingStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createClusterRoleBindingReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClusterDelegate) CreateClusterRoleBindingCallCount() int {
	fake.createClusterRoleBindingMutex.RLock()
	defer fake.createClusterRoleBindingMutex.RUnlock()
	return len(fake.createClusterRoleBindingArgsForCall)
}

func (fake *FakeClusterDelegate) CreateClusterRoleBindingCalls(stub func(*v1beta1.ClusterRoleBinding) (*v1beta1.ClusterRoleBinding, error)) {
	fake.createClusterRoleBindingMutex.Lock()
	defer fake.createClusterRoleBindingMutex.Unlock()
	fake.CreateClusterRoleBindingStub = stub
}

func (fake *FakeClusterDelegate) CreateClusterRoleBindingArgsForCall(i int) *v1beta1.ClusterRoleBinding {
	fake.createClusterRoleBindingMutex.RLock()
	defer fake.createClusterRoleBindingMutex.RUnlock()
	argsForCall := fake.createClusterRoleBindingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClusterDelegate) CreateClusterRoleBindingReturns(result1 *v1beta1.ClusterRoleBinding, result2 error) {
	fake.createClusterRoleBindingMutex.Lock()
	defer fake.createClusterRoleBindingMutex.Unlock()
	fake.CreateClusterRoleBindingStub = nil
	fake.createClusterRoleBindingReturns = struct {
		result1 *v1beta1.ClusterRoleBinding
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) CreateClusterRoleBindingReturnsOnCall(i int, result1 *v1beta1.ClusterRoleBinding, result2 error) {
	fake.createClusterRoleBindingMutex.Lock()
	defer fake.createClusterRoleBindingMutex.Unlock()
	fake.CreateClusterRoleBindingStub = nil
	if fake.createClusterRoleBindingReturnsOnCall == nil {
		fake.createClusterRoleBindingReturnsOnCall = make(map[int]struct {
			result1 *v1beta1.ClusterRoleBinding
			result2 error
		})
	}
	fake.createClusterRoleBindingReturnsOnCall[i] = struct {
		result1 *v1beta1.ClusterRoleBinding
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) CreateNamespace(arg1 *v1.Namespace) (*v1.Namespace, error) {
	fake.createNamespaceMutex.Lock()
	ret, specificReturn := fake.createNamespaceReturnsOnCall[len(fake.createNamespaceArgsForCall)]
	fake.createNamespaceArgsForCall = append(fake.createNamespaceArgsForCall, struct {
		arg1 *v1.Namespace
	}{arg1})
	fake.recordInvocation("CreateNamespace", []interface{}{arg1})
	fake.createNamespaceMutex.Unlock()
	if fake.CreateNamespaceStub != nil {
		return fake.CreateNamespaceStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createNamespaceReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClusterDelegate) CreateNamespaceCallCount() int {
	fake.createNamespaceMutex.RLock()
	defer fake.createNamespaceMutex.RUnlock()
	return len(fake.createNamespaceArgsForCall)
}

func (fake *FakeClusterDelegate) CreateNamespaceCalls(stub func(*v1.Namespace) (*v1.Namespace, error)) {
	fake.createNamespaceMutex.Lock()
	defer fake.createNamespaceMutex.Unlock()
	fake.CreateNamespaceStub = stub
}

func (fake *FakeClusterDelegate) CreateNamespaceArgsForCall(i int) *v1.Namespace {
	fake.createNamespaceMutex.RLock()
	defer fake.createNamespaceMutex.RUnlock()
	argsForCall := fake.createNamespaceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClusterDelegate) CreateNamespaceReturns(result1 *v1.Namespace, result2 error) {
	fake.createNamespaceMutex.Lock()
	defer fake.createNamespaceMutex.Unlock()
	fake.CreateNamespaceStub = nil
	fake.createNamespaceReturns = struct {
		result1 *v1.Namespace
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) CreateNamespaceReturnsOnCall(i int, result1 *v1.Namespace, result2 error) {
	fake.createNamespaceMutex.Lock()
	defer fake.createNamespaceMutex.Unlock()
	fake.CreateNamespaceStub = nil
	if fake.createNamespaceReturnsOnCall == nil {
		fake.createNamespaceReturnsOnCall = make(map[int]struct {
			result1 *v1.Namespace
			result2 error
		})
	}
	fake.createNamespaceReturnsOnCall[i] = struct {
		result1 *v1.Namespace
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) CreateSecret(arg1 string, arg2 *v1.Secret) (*v1.Secret, error) {
	fake.createSecretMutex.Lock()
	ret, specificReturn := fake.createSecretReturnsOnCall[len(fake.createSecretArgsForCall)]
	fake.createSecretArgsForCall = append(fake.createSecretArgsForCall, struct {
		arg1 string
		arg2 *v1.Secret
	}{arg1, arg2})
	fake.recordInvocation("CreateSecret", []interface{}{arg1, arg2})
	fake.createSecretMutex.Unlock()
	if fake.CreateSecretStub != nil {
		return fake.CreateSecretStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createSecretReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClusterDelegate) CreateSecretCallCount() int {
	fake.createSecretMutex.RLock()
	defer fake.createSecretMutex.RUnlock()
	return len(fake.createSecretArgsForCall)
}

func (fake *FakeClusterDelegate) CreateSecretCalls(stub func(string, *v1.Secret) (*v1.Secret, error)) {
	fake.createSecretMutex.Lock()
	defer fake.createSecretMutex.Unlock()
	fake.CreateSecretStub = stub
}

func (fake *FakeClusterDelegate) CreateSecretArgsForCall(i int) (string, *v1.Secret) {
	fake.createSecretMutex.RLock()
	defer fake.createSecretMutex.RUnlock()
	argsForCall := fake.createSecretArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClusterDelegate) CreateSecretReturns(result1 *v1.Secret, result2 error) {
	fake.createSecretMutex.Lock()
	defer fake.createSecretMutex.Unlock()
	fake.CreateSecretStub = nil
	fake.createSecretReturns = struct {
		result1 *v1.Secret
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) CreateSecretReturnsOnCall(i int, result1 *v1.Secret, result2 error) {
	fake.createSecretMutex.Lock()
	defer fake.createSecretMutex.Unlock()
	fake.CreateSecretStub = nil
	if fake.createSecretReturnsOnCall == nil {
		fake.createSecretReturnsOnCall = make(map[int]struct {
			result1 *v1.Secret
			result2 error
		})
	}
	fake.createSecretReturnsOnCall[i] = struct {
		result1 *v1.Secret
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) CreateServiceAccount(arg1 string, arg2 *v1.ServiceAccount) (*v1.ServiceAccount, error) {
	fake.createServiceAccountMutex.Lock()
	ret, specificReturn := fake.createServiceAccountReturnsOnCall[len(fake.createServiceAccountArgsForCall)]
	fake.createServiceAccountArgsForCall = append(fake.createServiceAccountArgsForCall, struct {
		arg1 string
		arg2 *v1.ServiceAccount
	}{arg1, arg2})
	fake.recordInvocation("CreateServiceAccount", []interface{}{arg1, arg2})
	fake.createServiceAccountMutex.Unlock()
	if fake.CreateServiceAccountStub != nil {
		return fake.CreateServiceAccountStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createServiceAccountReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClusterDelegate) CreateServiceAccountCallCount() int {
	fake.createServiceAccountMutex.RLock()
	defer fake.createServiceAccountMutex.RUnlock()
	return len(fake.createServiceAccountArgsForCall)
}

func (fake *FakeClusterDelegate) CreateServiceAccountCalls(stub func(string, *v1.ServiceAccount) (*v1.ServiceAccount, error)) {
	fake.createServiceAccountMutex.Lock()
	defer fake.createServiceAccountMutex.Unlock()
	fake.CreateServiceAccountStub = stub
}

func (fake *FakeClusterDelegate) CreateServiceAccountArgsForCall(i int) (string, *v1.ServiceAccount) {
	fake.createServiceAccountMutex.RLock()
	defer fake.createServiceAccountMutex.RUnlock()
	argsForCall := fake.createServiceAccountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClusterDelegate) CreateServiceAccountReturns(result1 *v1.ServiceAccount, result2 error) {
	fake.createServiceAccountMutex.Lock()
	defer fake.createServiceAccountMutex.Unlock()
	fake.CreateServiceAccountStub = nil
	fake.createServiceAccountReturns = struct {
		result1 *v1.ServiceAccount
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) CreateServiceAccountReturnsOnCall(i int, result1 *v1.ServiceAccount, result2 error) {
	fake.createServiceAccountMutex.Lock()
	defer fake.createServiceAccountMutex.Unlock()
	fake.CreateServiceAccountStub = nil
	if fake.createServiceAccountReturnsOnCall == nil {
		fake.createServiceAccountReturnsOnCall = make(map[int]struct {
			result1 *v1.ServiceAccount
			result2 error
		})
	}
	fake.createServiceAccountReturnsOnCall[i] = struct {
		result1 *v1.ServiceAccount
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) DeleteNamespace(arg1 string, arg2 *v1a.DeleteOptions) error {
	fake.deleteNamespaceMutex.Lock()
	ret, specificReturn := fake.deleteNamespaceReturnsOnCall[len(fake.deleteNamespaceArgsForCall)]
	fake.deleteNamespaceArgsForCall = append(fake.deleteNamespaceArgsForCall, struct {
		arg1 string
		arg2 *v1a.DeleteOptions
	}{arg1, arg2})
	fake.recordInvocation("DeleteNamespace", []interface{}{arg1, arg2})
	fake.deleteNamespaceMutex.Unlock()
	if fake.DeleteNamespaceStub != nil {
		return fake.DeleteNamespaceStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteNamespaceReturns
	return fakeReturns.result1
}

func (fake *FakeClusterDelegate) DeleteNamespaceCallCount() int {
	fake.deleteNamespaceMutex.RLock()
	defer fake.deleteNamespaceMutex.RUnlock()
	return len(fake.deleteNamespaceArgsForCall)
}

func (fake *FakeClusterDelegate) DeleteNamespaceCalls(stub func(string, *v1a.DeleteOptions) error) {
	fake.deleteNamespaceMutex.Lock()
	defer fake.deleteNamespaceMutex.Unlock()
	fake.DeleteNamespaceStub = stub
}

func (fake *FakeClusterDelegate) DeleteNamespaceArgsForCall(i int) (string, *v1a.DeleteOptions) {
	fake.deleteNamespaceMutex.RLock()
	defer fake.deleteNamespaceMutex.RUnlock()
	argsForCall := fake.deleteNamespaceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClusterDelegate) DeleteNamespaceReturns(result1 error) {
	fake.deleteNamespaceMutex.Lock()
	defer fake.deleteNamespaceMutex.Unlock()
	fake.DeleteNamespaceStub = nil
	fake.deleteNamespaceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClusterDelegate) DeleteNamespaceReturnsOnCall(i int, result1 error) {
	fake.deleteNamespaceMutex.Lock()
	defer fake.deleteNamespaceMutex.Unlock()
	fake.DeleteNamespaceStub = nil
	if fake.deleteNamespaceReturnsOnCall == nil {
		fake.deleteNamespaceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteNamespaceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClusterDelegate) GetClient() kubernetes.Interface {
	fake.getClientMutex.Lock()
	ret, specificReturn := fake.getClientReturnsOnCall[len(fake.getClientArgsForCall)]
	fake.getClientArgsForCall = append(fake.getClientArgsForCall, struct {
	}{})
	fake.recordInvocation("GetClient", []interface{}{})
	fake.getClientMutex.Unlock()
	if fake.GetClientStub != nil {
		return fake.GetClientStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getClientReturns
	return fakeReturns.result1
}

func (fake *FakeClusterDelegate) GetClientCallCount() int {
	fake.getClientMutex.RLock()
	defer fake.getClientMutex.RUnlock()
	return len(fake.getClientArgsForCall)
}

func (fake *FakeClusterDelegate) GetClientCalls(stub func() kubernetes.Interface) {
	fake.getClientMutex.Lock()
	defer fake.getClientMutex.Unlock()
	fake.GetClientStub = stub
}

func (fake *FakeClusterDelegate) GetClientReturns(result1 kubernetes.Interface) {
	fake.getClientMutex.Lock()
	defer fake.getClientMutex.Unlock()
	fake.GetClientStub = nil
	fake.getClientReturns = struct {
		result1 kubernetes.Interface
	}{result1}
}

func (fake *FakeClusterDelegate) GetClientReturnsOnCall(i int, result1 kubernetes.Interface) {
	fake.getClientMutex.Lock()
	defer fake.getClientMutex.Unlock()
	fake.GetClientStub = nil
	if fake.getClientReturnsOnCall == nil {
		fake.getClientReturnsOnCall = make(map[int]struct {
			result1 kubernetes.Interface
		})
	}
	fake.getClientReturnsOnCall[i] = struct {
		result1 kubernetes.Interface
	}{result1}
}

func (fake *FakeClusterDelegate) GetClientConfig() *rest.Config {
	fake.getClientConfigMutex.Lock()
	ret, specificReturn := fake.getClientConfigReturnsOnCall[len(fake.getClientConfigArgsForCall)]
	fake.getClientConfigArgsForCall = append(fake.getClientConfigArgsForCall, struct {
	}{})
	fake.recordInvocation("GetClientConfig", []interface{}{})
	fake.getClientConfigMutex.Unlock()
	if fake.GetClientConfigStub != nil {
		return fake.GetClientConfigStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getClientConfigReturns
	return fakeReturns.result1
}

func (fake *FakeClusterDelegate) GetClientConfigCallCount() int {
	fake.getClientConfigMutex.RLock()
	defer fake.getClientConfigMutex.RUnlock()
	return len(fake.getClientConfigArgsForCall)
}

func (fake *FakeClusterDelegate) GetClientConfigCalls(stub func() *rest.Config) {
	fake.getClientConfigMutex.Lock()
	defer fake.getClientConfigMutex.Unlock()
	fake.GetClientConfigStub = stub
}

func (fake *FakeClusterDelegate) GetClientConfigReturns(result1 *rest.Config) {
	fake.getClientConfigMutex.Lock()
	defer fake.getClientConfigMutex.Unlock()
	fake.GetClientConfigStub = nil
	fake.getClientConfigReturns = struct {
		result1 *rest.Config
	}{result1}
}

func (fake *FakeClusterDelegate) GetClientConfigReturnsOnCall(i int, result1 *rest.Config) {
	fake.getClientConfigMutex.Lock()
	defer fake.getClientConfigMutex.Unlock()
	fake.GetClientConfigStub = nil
	if fake.getClientConfigReturnsOnCall == nil {
		fake.getClientConfigReturnsOnCall = make(map[int]struct {
			result1 *rest.Config
		})
	}
	fake.getClientConfigReturnsOnCall[i] = struct {
		result1 *rest.Config
	}{result1}
}

func (fake *FakeClusterDelegate) GetDeployment(arg1 string, arg2 string, arg3 v1a.GetOptions) (*v1beta1a.Deployment, error) {
	fake.getDeploymentMutex.Lock()
	ret, specificReturn := fake.getDeploymentReturnsOnCall[len(fake.getDeploymentArgsForCall)]
	fake.getDeploymentArgsForCall = append(fake.getDeploymentArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 v1a.GetOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetDeployment", []interface{}{arg1, arg2, arg3})
	fake.getDeploymentMutex.Unlock()
	if fake.GetDeploymentStub != nil {
		return fake.GetDeploymentStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getDeploymentReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClusterDelegate) GetDeploymentCallCount() int {
	fake.getDeploymentMutex.RLock()
	defer fake.getDeploymentMutex.RUnlock()
	return len(fake.getDeploymentArgsForCall)
}

func (fake *FakeClusterDelegate) GetDeploymentCalls(stub func(string, string, v1a.GetOptions) (*v1beta1a.Deployment, error)) {
	fake.getDeploymentMutex.Lock()
	defer fake.getDeploymentMutex.Unlock()
	fake.GetDeploymentStub = stub
}

func (fake *FakeClusterDelegate) GetDeploymentArgsForCall(i int) (string, string, v1a.GetOptions) {
	fake.getDeploymentMutex.RLock()
	defer fake.getDeploymentMutex.RUnlock()
	argsForCall := fake.getDeploymentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClusterDelegate) GetDeploymentReturns(result1 *v1beta1a.Deployment, result2 error) {
	fake.getDeploymentMutex.Lock()
	defer fake.getDeploymentMutex.Unlock()
	fake.GetDeploymentStub = nil
	fake.getDeploymentReturns = struct {
		result1 *v1beta1a.Deployment
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) GetDeploymentReturnsOnCall(i int, result1 *v1beta1a.Deployment, result2 error) {
	fake.getDeploymentMutex.Lock()
	defer fake.getDeploymentMutex.Unlock()
	fake.GetDeploymentStub = nil
	if fake.getDeploymentReturnsOnCall == nil {
		fake.getDeploymentReturnsOnCall = make(map[int]struct {
			result1 *v1beta1a.Deployment
			result2 error
		})
	}
	fake.getDeploymentReturnsOnCall[i] = struct {
		result1 *v1beta1a.Deployment
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) GetNamespace(arg1 string, arg2 *v1a.GetOptions) (*v1.Namespace, error) {
	fake.getNamespaceMutex.Lock()
	ret, specificReturn := fake.getNamespaceReturnsOnCall[len(fake.getNamespaceArgsForCall)]
	fake.getNamespaceArgsForCall = append(fake.getNamespaceArgsForCall, struct {
		arg1 string
		arg2 *v1a.GetOptions
	}{arg1, arg2})
	fake.recordInvocation("GetNamespace", []interface{}{arg1, arg2})
	fake.getNamespaceMutex.Unlock()
	if fake.GetNamespaceStub != nil {
		return fake.GetNamespaceStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getNamespaceReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClusterDelegate) GetNamespaceCallCount() int {
	fake.getNamespaceMutex.RLock()
	defer fake.getNamespaceMutex.RUnlock()
	return len(fake.getNamespaceArgsForCall)
}

func (fake *FakeClusterDelegate) GetNamespaceCalls(stub func(string, *v1a.GetOptions) (*v1.Namespace, error)) {
	fake.getNamespaceMutex.Lock()
	defer fake.getNamespaceMutex.Unlock()
	fake.GetNamespaceStub = stub
}

func (fake *FakeClusterDelegate) GetNamespaceArgsForCall(i int) (string, *v1a.GetOptions) {
	fake.getNamespaceMutex.RLock()
	defer fake.getNamespaceMutex.RUnlock()
	argsForCall := fake.getNamespaceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClusterDelegate) GetNamespaceReturns(result1 *v1.Namespace, result2 error) {
	fake.getNamespaceMutex.Lock()
	defer fake.getNamespaceMutex.Unlock()
	fake.GetNamespaceStub = nil
	fake.getNamespaceReturns = struct {
		result1 *v1.Namespace
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) GetNamespaceReturnsOnCall(i int, result1 *v1.Namespace, result2 error) {
	fake.getNamespaceMutex.Lock()
	defer fake.getNamespaceMutex.Unlock()
	fake.GetNamespaceStub = nil
	if fake.getNamespaceReturnsOnCall == nil {
		fake.getNamespaceReturnsOnCall = make(map[int]struct {
			result1 *v1.Namespace
			result2 error
		})
	}
	fake.getNamespaceReturnsOnCall[i] = struct {
		result1 *v1.Namespace
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) GetNamespaces() (*v1.NamespaceList, error) {
	fake.getNamespacesMutex.Lock()
	ret, specificReturn := fake.getNamespacesReturnsOnCall[len(fake.getNamespacesArgsForCall)]
	fake.getNamespacesArgsForCall = append(fake.getNamespacesArgsForCall, struct {
	}{})
	fake.recordInvocation("GetNamespaces", []interface{}{})
	fake.getNamespacesMutex.Unlock()
	if fake.GetNamespacesStub != nil {
		return fake.GetNamespacesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getNamespacesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClusterDelegate) GetNamespacesCallCount() int {
	fake.getNamespacesMutex.RLock()
	defer fake.getNamespacesMutex.RUnlock()
	return len(fake.getNamespacesArgsForCall)
}

func (fake *FakeClusterDelegate) GetNamespacesCalls(stub func() (*v1.NamespaceList, error)) {
	fake.getNamespacesMutex.Lock()
	defer fake.getNamespacesMutex.Unlock()
	fake.GetNamespacesStub = stub
}

func (fake *FakeClusterDelegate) GetNamespacesReturns(result1 *v1.NamespaceList, result2 error) {
	fake.getNamespacesMutex.Lock()
	defer fake.getNamespacesMutex.Unlock()
	fake.GetNamespacesStub = nil
	fake.getNamespacesReturns = struct {
		result1 *v1.NamespaceList
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) GetNamespacesReturnsOnCall(i int, result1 *v1.NamespaceList, result2 error) {
	fake.getNamespacesMutex.Lock()
	defer fake.getNamespacesMutex.Unlock()
	fake.GetNamespacesStub = nil
	if fake.getNamespacesReturnsOnCall == nil {
		fake.getNamespacesReturnsOnCall = make(map[int]struct {
			result1 *v1.NamespaceList
			result2 error
		})
	}
	fake.getNamespacesReturnsOnCall[i] = struct {
		result1 *v1.NamespaceList
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) GetSecret(arg1 string, arg2 string, arg3 v1a.GetOptions) (*v1.Secret, error) {
	fake.getSecretMutex.Lock()
	ret, specificReturn := fake.getSecretReturnsOnCall[len(fake.getSecretArgsForCall)]
	fake.getSecretArgsForCall = append(fake.getSecretArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 v1a.GetOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetSecret", []interface{}{arg1, arg2, arg3})
	fake.getSecretMutex.Unlock()
	if fake.GetSecretStub != nil {
		return fake.GetSecretStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getSecretReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClusterDelegate) GetSecretCallCount() int {
	fake.getSecretMutex.RLock()
	defer fake.getSecretMutex.RUnlock()
	return len(fake.getSecretArgsForCall)
}

func (fake *FakeClusterDelegate) GetSecretCalls(stub func(string, string, v1a.GetOptions) (*v1.Secret, error)) {
	fake.getSecretMutex.Lock()
	defer fake.getSecretMutex.Unlock()
	fake.GetSecretStub = stub
}

func (fake *FakeClusterDelegate) GetSecretArgsForCall(i int) (string, string, v1a.GetOptions) {
	fake.getSecretMutex.RLock()
	defer fake.getSecretMutex.RUnlock()
	argsForCall := fake.getSecretArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClusterDelegate) GetSecretReturns(result1 *v1.Secret, result2 error) {
	fake.getSecretMutex.Lock()
	defer fake.getSecretMutex.Unlock()
	fake.GetSecretStub = nil
	fake.getSecretReturns = struct {
		result1 *v1.Secret
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) GetSecretReturnsOnCall(i int, result1 *v1.Secret, result2 error) {
	fake.getSecretMutex.Lock()
	defer fake.getSecretMutex.Unlock()
	fake.GetSecretStub = nil
	if fake.getSecretReturnsOnCall == nil {
		fake.getSecretReturnsOnCall = make(map[int]struct {
			result1 *v1.Secret
			result2 error
		})
	}
	fake.getSecretReturnsOnCall[i] = struct {
		result1 *v1.Secret
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) ListClusterRoleBindings(arg1 v1a.ListOptions) (*v1beta1.ClusterRoleBindingList, error) {
	fake.listClusterRoleBindingsMutex.Lock()
	ret, specificReturn := fake.listClusterRoleBindingsReturnsOnCall[len(fake.listClusterRoleBindingsArgsForCall)]
	fake.listClusterRoleBindingsArgsForCall = append(fake.listClusterRoleBindingsArgsForCall, struct {
		arg1 v1a.ListOptions
	}{arg1})
	fake.recordInvocation("ListClusterRoleBindings", []interface{}{arg1})
	fake.listClusterRoleBindingsMutex.Unlock()
	if fake.ListClusterRoleBindingsStub != nil {
		return fake.ListClusterRoleBindingsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listClusterRoleBindingsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClusterDelegate) ListClusterRoleBindingsCallCount() int {
	fake.listClusterRoleBindingsMutex.RLock()
	defer fake.listClusterRoleBindingsMutex.RUnlock()
	return len(fake.listClusterRoleBindingsArgsForCall)
}

func (fake *FakeClusterDelegate) ListClusterRoleBindingsCalls(stub func(v1a.ListOptions) (*v1beta1.ClusterRoleBindingList, error)) {
	fake.listClusterRoleBindingsMutex.Lock()
	defer fake.listClusterRoleBindingsMutex.Unlock()
	fake.ListClusterRoleBindingsStub = stub
}

func (fake *FakeClusterDelegate) ListClusterRoleBindingsArgsForCall(i int) v1a.ListOptions {
	fake.listClusterRoleBindingsMutex.RLock()
	defer fake.listClusterRoleBindingsMutex.RUnlock()
	argsForCall := fake.listClusterRoleBindingsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClusterDelegate) ListClusterRoleBindingsReturns(result1 *v1beta1.ClusterRoleBindingList, result2 error) {
	fake.listClusterRoleBindingsMutex.Lock()
	defer fake.listClusterRoleBindingsMutex.Unlock()
	fake.ListClusterRoleBindingsStub = nil
	fake.listClusterRoleBindingsReturns = struct {
		result1 *v1beta1.ClusterRoleBindingList
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) ListClusterRoleBindingsReturnsOnCall(i int, result1 *v1beta1.ClusterRoleBindingList, result2 error) {
	fake.listClusterRoleBindingsMutex.Lock()
	defer fake.listClusterRoleBindingsMutex.Unlock()
	fake.ListClusterRoleBindingsStub = nil
	if fake.listClusterRoleBindingsReturnsOnCall == nil {
		fake.listClusterRoleBindingsReturnsOnCall = make(map[int]struct {
			result1 *v1beta1.ClusterRoleBindingList
			result2 error
		})
	}
	fake.listClusterRoleBindingsReturnsOnCall[i] = struct {
		result1 *v1beta1.ClusterRoleBindingList
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) ListDeployments(arg1 string, arg2 v1a.ListOptions) (*k8s.DeploymentList, error) {
	fake.listDeploymentsMutex.Lock()
	ret, specificReturn := fake.listDeploymentsReturnsOnCall[len(fake.listDeploymentsArgsForCall)]
	fake.listDeploymentsArgsForCall = append(fake.listDeploymentsArgsForCall, struct {
		arg1 string
		arg2 v1a.ListOptions
	}{arg1, arg2})
	fake.recordInvocation("ListDeployments", []interface{}{arg1, arg2})
	fake.listDeploymentsMutex.Unlock()
	if fake.ListDeploymentsStub != nil {
		return fake.ListDeploymentsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listDeploymentsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClusterDelegate) ListDeploymentsCallCount() int {
	fake.listDeploymentsMutex.RLock()
	defer fake.listDeploymentsMutex.RUnlock()
	return len(fake.listDeploymentsArgsForCall)
}

func (fake *FakeClusterDelegate) ListDeploymentsCalls(stub func(string, v1a.ListOptions) (*k8s.DeploymentList, error)) {
	fake.listDeploymentsMutex.Lock()
	defer fake.listDeploymentsMutex.Unlock()
	fake.ListDeploymentsStub = stub
}

func (fake *FakeClusterDelegate) ListDeploymentsArgsForCall(i int) (string, v1a.ListOptions) {
	fake.listDeploymentsMutex.RLock()
	defer fake.listDeploymentsMutex.RUnlock()
	argsForCall := fake.listDeploymentsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClusterDelegate) ListDeploymentsReturns(result1 *k8s.DeploymentList, result2 error) {
	fake.listDeploymentsMutex.Lock()
	defer fake.listDeploymentsMutex.Unlock()
	fake.ListDeploymentsStub = nil
	fake.listDeploymentsReturns = struct {
		result1 *k8s.DeploymentList
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) ListDeploymentsReturnsOnCall(i int, result1 *k8s.DeploymentList, result2 error) {
	fake.listDeploymentsMutex.Lock()
	defer fake.listDeploymentsMutex.Unlock()
	fake.ListDeploymentsStub = nil
	if fake.listDeploymentsReturnsOnCall == nil {
		fake.listDeploymentsReturnsOnCall = make(map[int]struct {
			result1 *k8s.DeploymentList
			result2 error
		})
	}
	fake.listDeploymentsReturnsOnCall[i] = struct {
		result1 *k8s.DeploymentList
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) ListIngresses(arg1 string, arg2 v1a.ListOptions) (*v1beta1a.IngressList, error) {
	fake.listIngressesMutex.Lock()
	ret, specificReturn := fake.listIngressesReturnsOnCall[len(fake.listIngressesArgsForCall)]
	fake.listIngressesArgsForCall = append(fake.listIngressesArgsForCall, struct {
		arg1 string
		arg2 v1a.ListOptions
	}{arg1, arg2})
	fake.recordInvocation("ListIngresses", []interface{}{arg1, arg2})
	fake.listIngressesMutex.Unlock()
	if fake.ListIngressesStub != nil {
		return fake.ListIngressesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listIngressesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClusterDelegate) ListIngressesCallCount() int {
	fake.listIngressesMutex.RLock()
	defer fake.listIngressesMutex.RUnlock()
	return len(fake.listIngressesArgsForCall)
}

func (fake *FakeClusterDelegate) ListIngressesCalls(stub func(string, v1a.ListOptions) (*v1beta1a.IngressList, error)) {
	fake.listIngressesMutex.Lock()
	defer fake.listIngressesMutex.Unlock()
	fake.ListIngressesStub = stub
}

func (fake *FakeClusterDelegate) ListIngressesArgsForCall(i int) (string, v1a.ListOptions) {
	fake.listIngressesMutex.RLock()
	defer fake.listIngressesMutex.RUnlock()
	argsForCall := fake.listIngressesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClusterDelegate) ListIngressesReturns(result1 *v1beta1a.IngressList, result2 error) {
	fake.listIngressesMutex.Lock()
	defer fake.listIngressesMutex.Unlock()
	fake.ListIngressesStub = nil
	fake.listIngressesReturns = struct {
		result1 *v1beta1a.IngressList
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) ListIngressesReturnsOnCall(i int, result1 *v1beta1a.IngressList, result2 error) {
	fake.listIngressesMutex.Lock()
	defer fake.listIngressesMutex.Unlock()
	fake.ListIngressesStub = nil
	if fake.listIngressesReturnsOnCall == nil {
		fake.listIngressesReturnsOnCall = make(map[int]struct {
			result1 *v1beta1a.IngressList
			result2 error
		})
	}
	fake.listIngressesReturnsOnCall[i] = struct {
		result1 *v1beta1a.IngressList
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) ListNodes(arg1 v1a.ListOptions) (*v1.NodeList, error) {
	fake.listNodesMutex.Lock()
	ret, specificReturn := fake.listNodesReturnsOnCall[len(fake.listNodesArgsForCall)]
	fake.listNodesArgsForCall = append(fake.listNodesArgsForCall, struct {
		arg1 v1a.ListOptions
	}{arg1})
	fake.recordInvocation("ListNodes", []interface{}{arg1})
	fake.listNodesMutex.Unlock()
	if fake.ListNodesStub != nil {
		return fake.ListNodesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listNodesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClusterDelegate) ListNodesCallCount() int {
	fake.listNodesMutex.RLock()
	defer fake.listNodesMutex.RUnlock()
	return len(fake.listNodesArgsForCall)
}

func (fake *FakeClusterDelegate) ListNodesCalls(stub func(v1a.ListOptions) (*v1.NodeList, error)) {
	fake.listNodesMutex.Lock()
	defer fake.listNodesMutex.Unlock()
	fake.ListNodesStub = stub
}

func (fake *FakeClusterDelegate) ListNodesArgsForCall(i int) v1a.ListOptions {
	fake.listNodesMutex.RLock()
	defer fake.listNodesMutex.RUnlock()
	argsForCall := fake.listNodesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClusterDelegate) ListNodesReturns(result1 *v1.NodeList, result2 error) {
	fake.listNodesMutex.Lock()
	defer fake.listNodesMutex.Unlock()
	fake.ListNodesStub = nil
	fake.listNodesReturns = struct {
		result1 *v1.NodeList
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) ListNodesReturnsOnCall(i int, result1 *v1.NodeList, result2 error) {
	fake.listNodesMutex.Lock()
	defer fake.listNodesMutex.Unlock()
	fake.ListNodesStub = nil
	if fake.listNodesReturnsOnCall == nil {
		fake.listNodesReturnsOnCall = make(map[int]struct {
			result1 *v1.NodeList
			result2 error
		})
	}
	fake.listNodesReturnsOnCall[i] = struct {
		result1 *v1.NodeList
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) ListPersistentVolumes(arg1 string, arg2 v1a.ListOptions) (*v1.PersistentVolumeClaimList, error) {
	fake.listPersistentVolumesMutex.Lock()
	ret, specificReturn := fake.listPersistentVolumesReturnsOnCall[len(fake.listPersistentVolumesArgsForCall)]
	fake.listPersistentVolumesArgsForCall = append(fake.listPersistentVolumesArgsForCall, struct {
		arg1 string
		arg2 v1a.ListOptions
	}{arg1, arg2})
	fake.recordInvocation("ListPersistentVolumes", []interface{}{arg1, arg2})
	fake.listPersistentVolumesMutex.Unlock()
	if fake.ListPersistentVolumesStub != nil {
		return fake.ListPersistentVolumesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listPersistentVolumesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClusterDelegate) ListPersistentVolumesCallCount() int {
	fake.listPersistentVolumesMutex.RLock()
	defer fake.listPersistentVolumesMutex.RUnlock()
	return len(fake.listPersistentVolumesArgsForCall)
}

func (fake *FakeClusterDelegate) ListPersistentVolumesCalls(stub func(string, v1a.ListOptions) (*v1.PersistentVolumeClaimList, error)) {
	fake.listPersistentVolumesMutex.Lock()
	defer fake.listPersistentVolumesMutex.Unlock()
	fake.ListPersistentVolumesStub = stub
}

func (fake *FakeClusterDelegate) ListPersistentVolumesArgsForCall(i int) (string, v1a.ListOptions) {
	fake.listPersistentVolumesMutex.RLock()
	defer fake.listPersistentVolumesMutex.RUnlock()
	argsForCall := fake.listPersistentVolumesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClusterDelegate) ListPersistentVolumesReturns(result1 *v1.PersistentVolumeClaimList, result2 error) {
	fake.listPersistentVolumesMutex.Lock()
	defer fake.listPersistentVolumesMutex.Unlock()
	fake.ListPersistentVolumesStub = nil
	fake.listPersistentVolumesReturns = struct {
		result1 *v1.PersistentVolumeClaimList
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) ListPersistentVolumesReturnsOnCall(i int, result1 *v1.PersistentVolumeClaimList, result2 error) {
	fake.listPersistentVolumesMutex.Lock()
	defer fake.listPersistentVolumesMutex.Unlock()
	fake.ListPersistentVolumesStub = nil
	if fake.listPersistentVolumesReturnsOnCall == nil {
		fake.listPersistentVolumesReturnsOnCall = make(map[int]struct {
			result1 *v1.PersistentVolumeClaimList
			result2 error
		})
	}
	fake.listPersistentVolumesReturnsOnCall[i] = struct {
		result1 *v1.PersistentVolumeClaimList
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) ListPods(arg1 string, arg2 v1a.ListOptions) (*v1.PodList, error) {
	fake.listPodsMutex.Lock()
	ret, specificReturn := fake.listPodsReturnsOnCall[len(fake.listPodsArgsForCall)]
	fake.listPodsArgsForCall = append(fake.listPodsArgsForCall, struct {
		arg1 string
		arg2 v1a.ListOptions
	}{arg1, arg2})
	fake.recordInvocation("ListPods", []interface{}{arg1, arg2})
	fake.listPodsMutex.Unlock()
	if fake.ListPodsStub != nil {
		return fake.ListPodsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listPodsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClusterDelegate) ListPodsCallCount() int {
	fake.listPodsMutex.RLock()
	defer fake.listPodsMutex.RUnlock()
	return len(fake.listPodsArgsForCall)
}

func (fake *FakeClusterDelegate) ListPodsCalls(stub func(string, v1a.ListOptions) (*v1.PodList, error)) {
	fake.listPodsMutex.Lock()
	defer fake.listPodsMutex.Unlock()
	fake.ListPodsStub = stub
}

func (fake *FakeClusterDelegate) ListPodsArgsForCall(i int) (string, v1a.ListOptions) {
	fake.listPodsMutex.RLock()
	defer fake.listPodsMutex.RUnlock()
	argsForCall := fake.listPodsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClusterDelegate) ListPodsReturns(result1 *v1.PodList, result2 error) {
	fake.listPodsMutex.Lock()
	defer fake.listPodsMutex.Unlock()
	fake.ListPodsStub = nil
	fake.listPodsReturns = struct {
		result1 *v1.PodList
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) ListPodsReturnsOnCall(i int, result1 *v1.PodList, result2 error) {
	fake.listPodsMutex.Lock()
	defer fake.listPodsMutex.Unlock()
	fake.ListPodsStub = nil
	if fake.listPodsReturnsOnCall == nil {
		fake.listPodsReturnsOnCall = make(map[int]struct {
			result1 *v1.PodList
			result2 error
		})
	}
	fake.listPodsReturnsOnCall[i] = struct {
		result1 *v1.PodList
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) ListSecrets(arg1 string, arg2 v1a.ListOptions) (*v1.SecretList, error) {
	fake.listSecretsMutex.Lock()
	ret, specificReturn := fake.listSecretsReturnsOnCall[len(fake.listSecretsArgsForCall)]
	fake.listSecretsArgsForCall = append(fake.listSecretsArgsForCall, struct {
		arg1 string
		arg2 v1a.ListOptions
	}{arg1, arg2})
	fake.recordInvocation("ListSecrets", []interface{}{arg1, arg2})
	fake.listSecretsMutex.Unlock()
	if fake.ListSecretsStub != nil {
		return fake.ListSecretsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listSecretsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClusterDelegate) ListSecretsCallCount() int {
	fake.listSecretsMutex.RLock()
	defer fake.listSecretsMutex.RUnlock()
	return len(fake.listSecretsArgsForCall)
}

func (fake *FakeClusterDelegate) ListSecretsCalls(stub func(string, v1a.ListOptions) (*v1.SecretList, error)) {
	fake.listSecretsMutex.Lock()
	defer fake.listSecretsMutex.Unlock()
	fake.ListSecretsStub = stub
}

func (fake *FakeClusterDelegate) ListSecretsArgsForCall(i int) (string, v1a.ListOptions) {
	fake.listSecretsMutex.RLock()
	defer fake.listSecretsMutex.RUnlock()
	argsForCall := fake.listSecretsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClusterDelegate) ListSecretsReturns(result1 *v1.SecretList, result2 error) {
	fake.listSecretsMutex.Lock()
	defer fake.listSecretsMutex.Unlock()
	fake.ListSecretsStub = nil
	fake.listSecretsReturns = struct {
		result1 *v1.SecretList
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) ListSecretsReturnsOnCall(i int, result1 *v1.SecretList, result2 error) {
	fake.listSecretsMutex.Lock()
	defer fake.listSecretsMutex.Unlock()
	fake.ListSecretsStub = nil
	if fake.listSecretsReturnsOnCall == nil {
		fake.listSecretsReturnsOnCall = make(map[int]struct {
			result1 *v1.SecretList
			result2 error
		})
	}
	fake.listSecretsReturnsOnCall[i] = struct {
		result1 *v1.SecretList
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) ListServiceAccounts(arg1 string, arg2 v1a.ListOptions) (*v1.ServiceAccountList, error) {
	fake.listServiceAccountsMutex.Lock()
	ret, specificReturn := fake.listServiceAccountsReturnsOnCall[len(fake.listServiceAccountsArgsForCall)]
	fake.listServiceAccountsArgsForCall = append(fake.listServiceAccountsArgsForCall, struct {
		arg1 string
		arg2 v1a.ListOptions
	}{arg1, arg2})
	fake.recordInvocation("ListServiceAccounts", []interface{}{arg1, arg2})
	fake.listServiceAccountsMutex.Unlock()
	if fake.ListServiceAccountsStub != nil {
		return fake.ListServiceAccountsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listServiceAccountsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClusterDelegate) ListServiceAccountsCallCount() int {
	fake.listServiceAccountsMutex.RLock()
	defer fake.listServiceAccountsMutex.RUnlock()
	return len(fake.listServiceAccountsArgsForCall)
}

func (fake *FakeClusterDelegate) ListServiceAccountsCalls(stub func(string, v1a.ListOptions) (*v1.ServiceAccountList, error)) {
	fake.listServiceAccountsMutex.Lock()
	defer fake.listServiceAccountsMutex.Unlock()
	fake.ListServiceAccountsStub = stub
}

func (fake *FakeClusterDelegate) ListServiceAccountsArgsForCall(i int) (string, v1a.ListOptions) {
	fake.listServiceAccountsMutex.RLock()
	defer fake.listServiceAccountsMutex.RUnlock()
	argsForCall := fake.listServiceAccountsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClusterDelegate) ListServiceAccountsReturns(result1 *v1.ServiceAccountList, result2 error) {
	fake.listServiceAccountsMutex.Lock()
	defer fake.listServiceAccountsMutex.Unlock()
	fake.ListServiceAccountsStub = nil
	fake.listServiceAccountsReturns = struct {
		result1 *v1.ServiceAccountList
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) ListServiceAccountsReturnsOnCall(i int, result1 *v1.ServiceAccountList, result2 error) {
	fake.listServiceAccountsMutex.Lock()
	defer fake.listServiceAccountsMutex.Unlock()
	fake.ListServiceAccountsStub = nil
	if fake.listServiceAccountsReturnsOnCall == nil {
		fake.listServiceAccountsReturnsOnCall = make(map[int]struct {
			result1 *v1.ServiceAccountList
			result2 error
		})
	}
	fake.listServiceAccountsReturnsOnCall[i] = struct {
		result1 *v1.ServiceAccountList
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) ListServices(arg1 string, arg2 v1a.ListOptions) (*v1.ServiceList, error) {
	fake.listServicesMutex.Lock()
	ret, specificReturn := fake.listServicesReturnsOnCall[len(fake.listServicesArgsForCall)]
	fake.listServicesArgsForCall = append(fake.listServicesArgsForCall, struct {
		arg1 string
		arg2 v1a.ListOptions
	}{arg1, arg2})
	fake.recordInvocation("ListServices", []interface{}{arg1, arg2})
	fake.listServicesMutex.Unlock()
	if fake.ListServicesStub != nil {
		return fake.ListServicesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listServicesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClusterDelegate) ListServicesCallCount() int {
	fake.listServicesMutex.RLock()
	defer fake.listServicesMutex.RUnlock()
	return len(fake.listServicesArgsForCall)
}

func (fake *FakeClusterDelegate) ListServicesCalls(stub func(string, v1a.ListOptions) (*v1.ServiceList, error)) {
	fake.listServicesMutex.Lock()
	defer fake.listServicesMutex.Unlock()
	fake.ListServicesStub = stub
}

func (fake *FakeClusterDelegate) ListServicesArgsForCall(i int) (string, v1a.ListOptions) {
	fake.listServicesMutex.RLock()
	defer fake.listServicesMutex.RUnlock()
	argsForCall := fake.listServicesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClusterDelegate) ListServicesReturns(result1 *v1.ServiceList, result2 error) {
	fake.listServicesMutex.Lock()
	defer fake.listServicesMutex.Unlock()
	fake.ListServicesStub = nil
	fake.listServicesReturns = struct {
		result1 *v1.ServiceList
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) ListServicesReturnsOnCall(i int, result1 *v1.ServiceList, result2 error) {
	fake.listServicesMutex.Lock()
	defer fake.listServicesMutex.Unlock()
	fake.ListServicesStub = nil
	if fake.listServicesReturnsOnCall == nil {
		fake.listServicesReturnsOnCall = make(map[int]struct {
			result1 *v1.ServiceList
			result2 error
		})
	}
	fake.listServicesReturnsOnCall[i] = struct {
		result1 *v1.ServiceList
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) Patch(arg1 string, arg2 string, arg3 types.PatchType, arg4 []byte, arg5 ...string) (*v1.ServiceAccount, error) {
	var arg4Copy []byte
	if arg4 != nil {
		arg4Copy = make([]byte, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.patchMutex.Lock()
	ret, specificReturn := fake.patchReturnsOnCall[len(fake.patchArgsForCall)]
	fake.patchArgsForCall = append(fake.patchArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 types.PatchType
		arg4 []byte
		arg5 []string
	}{arg1, arg2, arg3, arg4Copy, arg5})
	fake.recordInvocation("Patch", []interface{}{arg1, arg2, arg3, arg4Copy, arg5})
	fake.patchMutex.Unlock()
	if fake.PatchStub != nil {
		return fake.PatchStub(arg1, arg2, arg3, arg4, arg5...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.patchReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClusterDelegate) PatchCallCount() int {
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	return len(fake.patchArgsForCall)
}

func (fake *FakeClusterDelegate) PatchCalls(stub func(string, string, types.PatchType, []byte, ...string) (*v1.ServiceAccount, error)) {
	fake.patchMutex.Lock()
	defer fake.patchMutex.Unlock()
	fake.PatchStub = stub
}

func (fake *FakeClusterDelegate) PatchArgsForCall(i int) (string, string, types.PatchType, []byte, []string) {
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	argsForCall := fake.patchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeClusterDelegate) PatchReturns(result1 *v1.ServiceAccount, result2 error) {
	fake.patchMutex.Lock()
	defer fake.patchMutex.Unlock()
	fake.PatchStub = nil
	fake.patchReturns = struct {
		result1 *v1.ServiceAccount
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) PatchReturnsOnCall(i int, result1 *v1.ServiceAccount, result2 error) {
	fake.patchMutex.Lock()
	defer fake.patchMutex.Unlock()
	fake.PatchStub = nil
	if fake.patchReturnsOnCall == nil {
		fake.patchReturnsOnCall = make(map[int]struct {
			result1 *v1.ServiceAccount
			result2 error
		})
	}
	fake.patchReturnsOnCall[i] = struct {
		result1 *v1.ServiceAccount
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) UpdateSecret(arg1 string, arg2 *v1.Secret) (*v1.Secret, error) {
	fake.updateSecretMutex.Lock()
	ret, specificReturn := fake.updateSecretReturnsOnCall[len(fake.updateSecretArgsForCall)]
	fake.updateSecretArgsForCall = append(fake.updateSecretArgsForCall, struct {
		arg1 string
		arg2 *v1.Secret
	}{arg1, arg2})
	fake.recordInvocation("UpdateSecret", []interface{}{arg1, arg2})
	fake.updateSecretMutex.Unlock()
	if fake.UpdateSecretStub != nil {
		return fake.UpdateSecretStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateSecretReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClusterDelegate) UpdateSecretCallCount() int {
	fake.updateSecretMutex.RLock()
	defer fake.updateSecretMutex.RUnlock()
	return len(fake.updateSecretArgsForCall)
}

func (fake *FakeClusterDelegate) UpdateSecretCalls(stub func(string, *v1.Secret) (*v1.Secret, error)) {
	fake.updateSecretMutex.Lock()
	defer fake.updateSecretMutex.Unlock()
	fake.UpdateSecretStub = stub
}

func (fake *FakeClusterDelegate) UpdateSecretArgsForCall(i int) (string, *v1.Secret) {
	fake.updateSecretMutex.RLock()
	defer fake.updateSecretMutex.RUnlock()
	argsForCall := fake.updateSecretArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClusterDelegate) UpdateSecretReturns(result1 *v1.Secret, result2 error) {
	fake.updateSecretMutex.Lock()
	defer fake.updateSecretMutex.Unlock()
	fake.UpdateSecretStub = nil
	fake.updateSecretReturns = struct {
		result1 *v1.Secret
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) UpdateSecretReturnsOnCall(i int, result1 *v1.Secret, result2 error) {
	fake.updateSecretMutex.Lock()
	defer fake.updateSecretMutex.Unlock()
	fake.UpdateSecretStub = nil
	if fake.updateSecretReturnsOnCall == nil {
		fake.updateSecretReturnsOnCall = make(map[int]struct {
			result1 *v1.Secret
			result2 error
		})
	}
	fake.updateSecretReturnsOnCall[i] = struct {
		result1 *v1.Secret
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterDelegate) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createClusterRoleBindingMutex.RLock()
	defer fake.createClusterRoleBindingMutex.RUnlock()
	fake.createNamespaceMutex.RLock()
	defer fake.createNamespaceMutex.RUnlock()
	fake.createSecretMutex.RLock()
	defer fake.createSecretMutex.RUnlock()
	fake.createServiceAccountMutex.RLock()
	defer fake.createServiceAccountMutex.RUnlock()
	fake.deleteNamespaceMutex.RLock()
	defer fake.deleteNamespaceMutex.RUnlock()
	fake.getClientMutex.RLock()
	defer fake.getClientMutex.RUnlock()
	fake.getClientConfigMutex.RLock()
	defer fake.getClientConfigMutex.RUnlock()
	fake.getDeploymentMutex.RLock()
	defer fake.getDeploymentMutex.RUnlock()
	fake.getNamespaceMutex.RLock()
	defer fake.getNamespaceMutex.RUnlock()
	fake.getNamespacesMutex.RLock()
	defer fake.getNamespacesMutex.RUnlock()
	fake.getSecretMutex.RLock()
	defer fake.getSecretMutex.RUnlock()
	fake.listClusterRoleBindingsMutex.RLock()
	defer fake.listClusterRoleBindingsMutex.RUnlock()
	fake.listDeploymentsMutex.RLock()
	defer fake.listDeploymentsMutex.RUnlock()
	fake.listIngressesMutex.RLock()
	defer fake.listIngressesMutex.RUnlock()
	fake.listNodesMutex.RLock()
	defer fake.listNodesMutex.RUnlock()
	fake.listPersistentVolumesMutex.RLock()
	defer fake.listPersistentVolumesMutex.RUnlock()
	fake.listPodsMutex.RLock()
	defer fake.listPodsMutex.RUnlock()
	fake.listSecretsMutex.RLock()
	defer fake.listSecretsMutex.RUnlock()
	fake.listServiceAccountsMutex.RLock()
	defer fake.listServiceAccountsMutex.RUnlock()
	fake.listServicesMutex.RLock()
	defer fake.listServicesMutex.RUnlock()
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	fake.updateSecretMutex.RLock()
	defer fake.updateSecretMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClusterDelegate) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ k8s.ClusterDelegate = new(FakeClusterDelegate)

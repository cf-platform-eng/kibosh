// Code generated by counterfeiter. DO NOT EDIT.
package helmfakes

import (
	"io"
	"sync"

	"github.com/cf-platform-eng/kibosh/pkg/config"
	"github.com/cf-platform-eng/kibosh/pkg/helm"
	"github.com/cf-platform-eng/kibosh/pkg/k8s"
	v1 "k8s.io/api/core/v1"
	"k8s.io/helm/cmd/helm/installer"
	"k8s.io/helm/pkg/chartutil"
	helma "k8s.io/helm/pkg/helm"
	"k8s.io/helm/pkg/proto/hapi/chart"
	"k8s.io/helm/pkg/proto/hapi/release"
	"k8s.io/helm/pkg/proto/hapi/services"
)

type FakeMyHelmClient struct {
	DeleteReleaseStub        func(string, ...helma.DeleteOption) (*services.UninstallReleaseResponse, error)
	deleteReleaseMutex       sync.RWMutex
	deleteReleaseArgsForCall []struct {
		arg1 string
		arg2 []helma.DeleteOption
	}
	deleteReleaseReturns struct {
		result1 *services.UninstallReleaseResponse
		result2 error
	}
	deleteReleaseReturnsOnCall map[int]struct {
		result1 *services.UninstallReleaseResponse
		result2 error
	}
	GetVersionStub        func(...helma.VersionOption) (*services.GetVersionResponse, error)
	getVersionMutex       sync.RWMutex
	getVersionArgsForCall []struct {
		arg1 []helma.VersionOption
	}
	getVersionReturns struct {
		result1 *services.GetVersionResponse
		result2 error
	}
	getVersionReturnsOnCall map[int]struct {
		result1 *services.GetVersionResponse
		result2 error
	}
	HasDifferentTLSConfigStub        func() bool
	hasDifferentTLSConfigMutex       sync.RWMutex
	hasDifferentTLSConfigArgsForCall []struct {
	}
	hasDifferentTLSConfigReturns struct {
		result1 bool
	}
	hasDifferentTLSConfigReturnsOnCall map[int]struct {
		result1 bool
	}
	InstallStub        func(*installer.Options) error
	installMutex       sync.RWMutex
	installArgsForCall []struct {
		arg1 *installer.Options
	}
	installReturns struct {
		result1 error
	}
	installReturnsOnCall map[int]struct {
		result1 error
	}
	InstallChartStub        func(*config.RegistryConfig, v1.Namespace, string, *helm.MyChart, string, []byte, ...helma.InstallOption) (*services.InstallReleaseResponse, error)
	installChartMutex       sync.RWMutex
	installChartArgsForCall []struct {
		arg1 *config.RegistryConfig
		arg2 v1.Namespace
		arg3 string
		arg4 *helm.MyChart
		arg5 string
		arg6 []byte
		arg7 []helma.InstallOption
	}
	installChartReturns struct {
		result1 *services.InstallReleaseResponse
		result2 error
	}
	installChartReturnsOnCall map[int]struct {
		result1 *services.InstallReleaseResponse
		result2 error
	}
	InstallOperatorStub        func(*helm.MyChart, string) (*services.InstallReleaseResponse, error)
	installOperatorMutex       sync.RWMutex
	installOperatorArgsForCall []struct {
		arg1 *helm.MyChart
		arg2 string
	}
	installOperatorReturns struct {
		result1 *services.InstallReleaseResponse
		result2 error
	}
	installOperatorReturnsOnCall map[int]struct {
		result1 *services.InstallReleaseResponse
		result2 error
	}
	InstallReleaseStub        func(string, string, ...helma.InstallOption) (*services.InstallReleaseResponse, error)
	installReleaseMutex       sync.RWMutex
	installReleaseArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []helma.InstallOption
	}
	installReleaseReturns struct {
		result1 *services.InstallReleaseResponse
		result2 error
	}
	installReleaseReturnsOnCall map[int]struct {
		result1 *services.InstallReleaseResponse
		result2 error
	}
	InstallReleaseFromChartStub        func(*chart.Chart, string, ...helma.InstallOption) (*services.InstallReleaseResponse, error)
	installReleaseFromChartMutex       sync.RWMutex
	installReleaseFromChartArgsForCall []struct {
		arg1 *chart.Chart
		arg2 string
		arg3 []helma.InstallOption
	}
	installReleaseFromChartReturns struct {
		result1 *services.InstallReleaseResponse
		result2 error
	}
	installReleaseFromChartReturnsOnCall map[int]struct {
		result1 *services.InstallReleaseResponse
		result2 error
	}
	ListReleasesStub        func(...helma.ReleaseListOption) (*services.ListReleasesResponse, error)
	listReleasesMutex       sync.RWMutex
	listReleasesArgsForCall []struct {
		arg1 []helma.ReleaseListOption
	}
	listReleasesReturns struct {
		result1 *services.ListReleasesResponse
		result2 error
	}
	listReleasesReturnsOnCall map[int]struct {
		result1 *services.ListReleasesResponse
		result2 error
	}
	MergeValueBytesStub        func([]byte, []byte) ([]byte, error)
	mergeValueBytesMutex       sync.RWMutex
	mergeValueBytesArgsForCall []struct {
		arg1 []byte
		arg2 []byte
	}
	mergeValueBytesReturns struct {
		result1 []byte
		result2 error
	}
	mergeValueBytesReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	PingTillerStub        func() error
	pingTillerMutex       sync.RWMutex
	pingTillerArgsForCall []struct {
	}
	pingTillerReturns struct {
		result1 error
	}
	pingTillerReturnsOnCall map[int]struct {
		result1 error
	}
	PrintStatusStub        func(io.Writer, string) error
	printStatusMutex       sync.RWMutex
	printStatusArgsForCall []struct {
		arg1 io.Writer
		arg2 string
	}
	printStatusReturns struct {
		result1 error
	}
	printStatusReturnsOnCall map[int]struct {
		result1 error
	}
	ReleaseContentStub        func(string, ...helma.ContentOption) (*services.GetReleaseContentResponse, error)
	releaseContentMutex       sync.RWMutex
	releaseContentArgsForCall []struct {
		arg1 string
		arg2 []helma.ContentOption
	}
	releaseContentReturns struct {
		result1 *services.GetReleaseContentResponse
		result2 error
	}
	releaseContentReturnsOnCall map[int]struct {
		result1 *services.GetReleaseContentResponse
		result2 error
	}
	ReleaseHistoryStub        func(string, ...helma.HistoryOption) (*services.GetHistoryResponse, error)
	releaseHistoryMutex       sync.RWMutex
	releaseHistoryArgsForCall []struct {
		arg1 string
		arg2 []helma.HistoryOption
	}
	releaseHistoryReturns struct {
		result1 *services.GetHistoryResponse
		result2 error
	}
	releaseHistoryReturnsOnCall map[int]struct {
		result1 *services.GetHistoryResponse
		result2 error
	}
	ReleaseStatusStub        func(string, ...helma.StatusOption) (*services.GetReleaseStatusResponse, error)
	releaseStatusMutex       sync.RWMutex
	releaseStatusArgsForCall []struct {
		arg1 string
		arg2 []helma.StatusOption
	}
	releaseStatusReturns struct {
		result1 *services.GetReleaseStatusResponse
		result2 error
	}
	releaseStatusReturnsOnCall map[int]struct {
		result1 *services.GetReleaseStatusResponse
		result2 error
	}
	RenderTemplatedValuesStub        func(chartutil.ReleaseOptions, []byte, chart.Chart) ([]byte, error)
	renderTemplatedValuesMutex       sync.RWMutex
	renderTemplatedValuesArgsForCall []struct {
		arg1 chartutil.ReleaseOptions
		arg2 []byte
		arg3 chart.Chart
	}
	renderTemplatedValuesReturns struct {
		result1 []byte
		result2 error
	}
	renderTemplatedValuesReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	ResourceReadinessStub        func(string, k8s.Cluster) (*string, release.Status_Code, error)
	resourceReadinessMutex       sync.RWMutex
	resourceReadinessArgsForCall []struct {
		arg1 string
		arg2 k8s.Cluster
	}
	resourceReadinessReturns struct {
		result1 *string
		result2 release.Status_Code
		result3 error
	}
	resourceReadinessReturnsOnCall map[int]struct {
		result1 *string
		result2 release.Status_Code
		result3 error
	}
	RollbackReleaseStub        func(string, ...helma.RollbackOption) (*services.RollbackReleaseResponse, error)
	rollbackReleaseMutex       sync.RWMutex
	rollbackReleaseArgsForCall []struct {
		arg1 string
		arg2 []helma.RollbackOption
	}
	rollbackReleaseReturns struct {
		result1 *services.RollbackReleaseResponse
		result2 error
	}
	rollbackReleaseReturnsOnCall map[int]struct {
		result1 *services.RollbackReleaseResponse
		result2 error
	}
	RunReleaseTestStub        func(string, ...helma.ReleaseTestOption) (<-chan *services.TestReleaseResponse, <-chan error)
	runReleaseTestMutex       sync.RWMutex
	runReleaseTestArgsForCall []struct {
		arg1 string
		arg2 []helma.ReleaseTestOption
	}
	runReleaseTestReturns struct {
		result1 <-chan *services.TestReleaseResponse
		result2 <-chan error
	}
	runReleaseTestReturnsOnCall map[int]struct {
		result1 <-chan *services.TestReleaseResponse
		result2 <-chan error
	}
	UninstallStub        func(*installer.Options) error
	uninstallMutex       sync.RWMutex
	uninstallArgsForCall []struct {
		arg1 *installer.Options
	}
	uninstallReturns struct {
		result1 error
	}
	uninstallReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateChartStub        func(*helm.MyChart, string, string, []byte) (*services.UpdateReleaseResponse, error)
	updateChartMutex       sync.RWMutex
	updateChartArgsForCall []struct {
		arg1 *helm.MyChart
		arg2 string
		arg3 string
		arg4 []byte
	}
	updateChartReturns struct {
		result1 *services.UpdateReleaseResponse
		result2 error
	}
	updateChartReturnsOnCall map[int]struct {
		result1 *services.UpdateReleaseResponse
		result2 error
	}
	UpdateReleaseStub        func(string, string, ...helma.UpdateOption) (*services.UpdateReleaseResponse, error)
	updateReleaseMutex       sync.RWMutex
	updateReleaseArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []helma.UpdateOption
	}
	updateReleaseReturns struct {
		result1 *services.UpdateReleaseResponse
		result2 error
	}
	updateReleaseReturnsOnCall map[int]struct {
		result1 *services.UpdateReleaseResponse
		result2 error
	}
	UpdateReleaseFromChartStub        func(string, *chart.Chart, ...helma.UpdateOption) (*services.UpdateReleaseResponse, error)
	updateReleaseFromChartMutex       sync.RWMutex
	updateReleaseFromChartArgsForCall []struct {
		arg1 string
		arg2 *chart.Chart
		arg3 []helma.UpdateOption
	}
	updateReleaseFromChartReturns struct {
		result1 *services.UpdateReleaseResponse
		result2 error
	}
	updateReleaseFromChartReturnsOnCall map[int]struct {
		result1 *services.UpdateReleaseResponse
		result2 error
	}
	UpgradeStub        func(*installer.Options) error
	upgradeMutex       sync.RWMutex
	upgradeArgsForCall []struct {
		arg1 *installer.Options
	}
	upgradeReturns struct {
		result1 error
	}
	upgradeReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeMyHelmClient) DeleteRelease(arg1 string, arg2 ...helma.DeleteOption) (*services.UninstallReleaseResponse, error) {
	fake.deleteReleaseMutex.Lock()
	ret, specificReturn := fake.deleteReleaseReturnsOnCall[len(fake.deleteReleaseArgsForCall)]
	fake.deleteReleaseArgsForCall = append(fake.deleteReleaseArgsForCall, struct {
		arg1 string
		arg2 []helma.DeleteOption
	}{arg1, arg2})
	fake.recordInvocation("DeleteRelease", []interface{}{arg1, arg2})
	fake.deleteReleaseMutex.Unlock()
	if fake.DeleteReleaseStub != nil {
		return fake.DeleteReleaseStub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteReleaseReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMyHelmClient) DeleteReleaseCallCount() int {
	fake.deleteReleaseMutex.RLock()
	defer fake.deleteReleaseMutex.RUnlock()
	return len(fake.deleteReleaseArgsForCall)
}

func (fake *FakeMyHelmClient) DeleteReleaseCalls(stub func(string, ...helma.DeleteOption) (*services.UninstallReleaseResponse, error)) {
	fake.deleteReleaseMutex.Lock()
	defer fake.deleteReleaseMutex.Unlock()
	fake.DeleteReleaseStub = stub
}

func (fake *FakeMyHelmClient) DeleteReleaseArgsForCall(i int) (string, []helma.DeleteOption) {
	fake.deleteReleaseMutex.RLock()
	defer fake.deleteReleaseMutex.RUnlock()
	argsForCall := fake.deleteReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMyHelmClient) DeleteReleaseReturns(result1 *services.UninstallReleaseResponse, result2 error) {
	fake.deleteReleaseMutex.Lock()
	defer fake.deleteReleaseMutex.Unlock()
	fake.DeleteReleaseStub = nil
	fake.deleteReleaseReturns = struct {
		result1 *services.UninstallReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) DeleteReleaseReturnsOnCall(i int, result1 *services.UninstallReleaseResponse, result2 error) {
	fake.deleteReleaseMutex.Lock()
	defer fake.deleteReleaseMutex.Unlock()
	fake.DeleteReleaseStub = nil
	if fake.deleteReleaseReturnsOnCall == nil {
		fake.deleteReleaseReturnsOnCall = make(map[int]struct {
			result1 *services.UninstallReleaseResponse
			result2 error
		})
	}
	fake.deleteReleaseReturnsOnCall[i] = struct {
		result1 *services.UninstallReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) GetVersion(arg1 ...helma.VersionOption) (*services.GetVersionResponse, error) {
	fake.getVersionMutex.Lock()
	ret, specificReturn := fake.getVersionReturnsOnCall[len(fake.getVersionArgsForCall)]
	fake.getVersionArgsForCall = append(fake.getVersionArgsForCall, struct {
		arg1 []helma.VersionOption
	}{arg1})
	fake.recordInvocation("GetVersion", []interface{}{arg1})
	fake.getVersionMutex.Unlock()
	if fake.GetVersionStub != nil {
		return fake.GetVersionStub(arg1...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getVersionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMyHelmClient) GetVersionCallCount() int {
	fake.getVersionMutex.RLock()
	defer fake.getVersionMutex.RUnlock()
	return len(fake.getVersionArgsForCall)
}

func (fake *FakeMyHelmClient) GetVersionCalls(stub func(...helma.VersionOption) (*services.GetVersionResponse, error)) {
	fake.getVersionMutex.Lock()
	defer fake.getVersionMutex.Unlock()
	fake.GetVersionStub = stub
}

func (fake *FakeMyHelmClient) GetVersionArgsForCall(i int) []helma.VersionOption {
	fake.getVersionMutex.RLock()
	defer fake.getVersionMutex.RUnlock()
	argsForCall := fake.getVersionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMyHelmClient) GetVersionReturns(result1 *services.GetVersionResponse, result2 error) {
	fake.getVersionMutex.Lock()
	defer fake.getVersionMutex.Unlock()
	fake.GetVersionStub = nil
	fake.getVersionReturns = struct {
		result1 *services.GetVersionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) GetVersionReturnsOnCall(i int, result1 *services.GetVersionResponse, result2 error) {
	fake.getVersionMutex.Lock()
	defer fake.getVersionMutex.Unlock()
	fake.GetVersionStub = nil
	if fake.getVersionReturnsOnCall == nil {
		fake.getVersionReturnsOnCall = make(map[int]struct {
			result1 *services.GetVersionResponse
			result2 error
		})
	}
	fake.getVersionReturnsOnCall[i] = struct {
		result1 *services.GetVersionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) HasDifferentTLSConfig() bool {
	fake.hasDifferentTLSConfigMutex.Lock()
	ret, specificReturn := fake.hasDifferentTLSConfigReturnsOnCall[len(fake.hasDifferentTLSConfigArgsForCall)]
	fake.hasDifferentTLSConfigArgsForCall = append(fake.hasDifferentTLSConfigArgsForCall, struct {
	}{})
	fake.recordInvocation("HasDifferentTLSConfig", []interface{}{})
	fake.hasDifferentTLSConfigMutex.Unlock()
	if fake.HasDifferentTLSConfigStub != nil {
		return fake.HasDifferentTLSConfigStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.hasDifferentTLSConfigReturns
	return fakeReturns.result1
}

func (fake *FakeMyHelmClient) HasDifferentTLSConfigCallCount() int {
	fake.hasDifferentTLSConfigMutex.RLock()
	defer fake.hasDifferentTLSConfigMutex.RUnlock()
	return len(fake.hasDifferentTLSConfigArgsForCall)
}

func (fake *FakeMyHelmClient) HasDifferentTLSConfigCalls(stub func() bool) {
	fake.hasDifferentTLSConfigMutex.Lock()
	defer fake.hasDifferentTLSConfigMutex.Unlock()
	fake.HasDifferentTLSConfigStub = stub
}

func (fake *FakeMyHelmClient) HasDifferentTLSConfigReturns(result1 bool) {
	fake.hasDifferentTLSConfigMutex.Lock()
	defer fake.hasDifferentTLSConfigMutex.Unlock()
	fake.HasDifferentTLSConfigStub = nil
	fake.hasDifferentTLSConfigReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeMyHelmClient) HasDifferentTLSConfigReturnsOnCall(i int, result1 bool) {
	fake.hasDifferentTLSConfigMutex.Lock()
	defer fake.hasDifferentTLSConfigMutex.Unlock()
	fake.HasDifferentTLSConfigStub = nil
	if fake.hasDifferentTLSConfigReturnsOnCall == nil {
		fake.hasDifferentTLSConfigReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasDifferentTLSConfigReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeMyHelmClient) Install(arg1 *installer.Options) error {
	fake.installMutex.Lock()
	ret, specificReturn := fake.installReturnsOnCall[len(fake.installArgsForCall)]
	fake.installArgsForCall = append(fake.installArgsForCall, struct {
		arg1 *installer.Options
	}{arg1})
	fake.recordInvocation("Install", []interface{}{arg1})
	fake.installMutex.Unlock()
	if fake.InstallStub != nil {
		return fake.InstallStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.installReturns
	return fakeReturns.result1
}

func (fake *FakeMyHelmClient) InstallCallCount() int {
	fake.installMutex.RLock()
	defer fake.installMutex.RUnlock()
	return len(fake.installArgsForCall)
}

func (fake *FakeMyHelmClient) InstallCalls(stub func(*installer.Options) error) {
	fake.installMutex.Lock()
	defer fake.installMutex.Unlock()
	fake.InstallStub = stub
}

func (fake *FakeMyHelmClient) InstallArgsForCall(i int) *installer.Options {
	fake.installMutex.RLock()
	defer fake.installMutex.RUnlock()
	argsForCall := fake.installArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMyHelmClient) InstallReturns(result1 error) {
	fake.installMutex.Lock()
	defer fake.installMutex.Unlock()
	fake.InstallStub = nil
	fake.installReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMyHelmClient) InstallReturnsOnCall(i int, result1 error) {
	fake.installMutex.Lock()
	defer fake.installMutex.Unlock()
	fake.InstallStub = nil
	if fake.installReturnsOnCall == nil {
		fake.installReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.installReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMyHelmClient) InstallChart(arg1 *config.RegistryConfig, arg2 v1.Namespace, arg3 string, arg4 *helm.MyChart, arg5 string, arg6 []byte, arg7 ...helma.InstallOption) (*services.InstallReleaseResponse, error) {
	var arg6Copy []byte
	if arg6 != nil {
		arg6Copy = make([]byte, len(arg6))
		copy(arg6Copy, arg6)
	}
	fake.installChartMutex.Lock()
	ret, specificReturn := fake.installChartReturnsOnCall[len(fake.installChartArgsForCall)]
	fake.installChartArgsForCall = append(fake.installChartArgsForCall, struct {
		arg1 *config.RegistryConfig
		arg2 v1.Namespace
		arg3 string
		arg4 *helm.MyChart
		arg5 string
		arg6 []byte
		arg7 []helma.InstallOption
	}{arg1, arg2, arg3, arg4, arg5, arg6Copy, arg7})
	fake.recordInvocation("InstallChart", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6Copy, arg7})
	fake.installChartMutex.Unlock()
	if fake.InstallChartStub != nil {
		return fake.InstallChartStub(arg1, arg2, arg3, arg4, arg5, arg6, arg7...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.installChartReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMyHelmClient) InstallChartCallCount() int {
	fake.installChartMutex.RLock()
	defer fake.installChartMutex.RUnlock()
	return len(fake.installChartArgsForCall)
}

func (fake *FakeMyHelmClient) InstallChartCalls(stub func(*config.RegistryConfig, v1.Namespace, string, *helm.MyChart, string, []byte, ...helma.InstallOption) (*services.InstallReleaseResponse, error)) {
	fake.installChartMutex.Lock()
	defer fake.installChartMutex.Unlock()
	fake.InstallChartStub = stub
}

func (fake *FakeMyHelmClient) InstallChartArgsForCall(i int) (*config.RegistryConfig, v1.Namespace, string, *helm.MyChart, string, []byte, []helma.InstallOption) {
	fake.installChartMutex.RLock()
	defer fake.installChartMutex.RUnlock()
	argsForCall := fake.installChartArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeMyHelmClient) InstallChartReturns(result1 *services.InstallReleaseResponse, result2 error) {
	fake.installChartMutex.Lock()
	defer fake.installChartMutex.Unlock()
	fake.InstallChartStub = nil
	fake.installChartReturns = struct {
		result1 *services.InstallReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) InstallChartReturnsOnCall(i int, result1 *services.InstallReleaseResponse, result2 error) {
	fake.installChartMutex.Lock()
	defer fake.installChartMutex.Unlock()
	fake.InstallChartStub = nil
	if fake.installChartReturnsOnCall == nil {
		fake.installChartReturnsOnCall = make(map[int]struct {
			result1 *services.InstallReleaseResponse
			result2 error
		})
	}
	fake.installChartReturnsOnCall[i] = struct {
		result1 *services.InstallReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) InstallOperator(arg1 *helm.MyChart, arg2 string) (*services.InstallReleaseResponse, error) {
	fake.installOperatorMutex.Lock()
	ret, specificReturn := fake.installOperatorReturnsOnCall[len(fake.installOperatorArgsForCall)]
	fake.installOperatorArgsForCall = append(fake.installOperatorArgsForCall, struct {
		arg1 *helm.MyChart
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("InstallOperator", []interface{}{arg1, arg2})
	fake.installOperatorMutex.Unlock()
	if fake.InstallOperatorStub != nil {
		return fake.InstallOperatorStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.installOperatorReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMyHelmClient) InstallOperatorCallCount() int {
	fake.installOperatorMutex.RLock()
	defer fake.installOperatorMutex.RUnlock()
	return len(fake.installOperatorArgsForCall)
}

func (fake *FakeMyHelmClient) InstallOperatorCalls(stub func(*helm.MyChart, string) (*services.InstallReleaseResponse, error)) {
	fake.installOperatorMutex.Lock()
	defer fake.installOperatorMutex.Unlock()
	fake.InstallOperatorStub = stub
}

func (fake *FakeMyHelmClient) InstallOperatorArgsForCall(i int) (*helm.MyChart, string) {
	fake.installOperatorMutex.RLock()
	defer fake.installOperatorMutex.RUnlock()
	argsForCall := fake.installOperatorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMyHelmClient) InstallOperatorReturns(result1 *services.InstallReleaseResponse, result2 error) {
	fake.installOperatorMutex.Lock()
	defer fake.installOperatorMutex.Unlock()
	fake.InstallOperatorStub = nil
	fake.installOperatorReturns = struct {
		result1 *services.InstallReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) InstallOperatorReturnsOnCall(i int, result1 *services.InstallReleaseResponse, result2 error) {
	fake.installOperatorMutex.Lock()
	defer fake.installOperatorMutex.Unlock()
	fake.InstallOperatorStub = nil
	if fake.installOperatorReturnsOnCall == nil {
		fake.installOperatorReturnsOnCall = make(map[int]struct {
			result1 *services.InstallReleaseResponse
			result2 error
		})
	}
	fake.installOperatorReturnsOnCall[i] = struct {
		result1 *services.InstallReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) InstallRelease(arg1 string, arg2 string, arg3 ...helma.InstallOption) (*services.InstallReleaseResponse, error) {
	fake.installReleaseMutex.Lock()
	ret, specificReturn := fake.installReleaseReturnsOnCall[len(fake.installReleaseArgsForCall)]
	fake.installReleaseArgsForCall = append(fake.installReleaseArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []helma.InstallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("InstallRelease", []interface{}{arg1, arg2, arg3})
	fake.installReleaseMutex.Unlock()
	if fake.InstallReleaseStub != nil {
		return fake.InstallReleaseStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.installReleaseReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMyHelmClient) InstallReleaseCallCount() int {
	fake.installReleaseMutex.RLock()
	defer fake.installReleaseMutex.RUnlock()
	return len(fake.installReleaseArgsForCall)
}

func (fake *FakeMyHelmClient) InstallReleaseCalls(stub func(string, string, ...helma.InstallOption) (*services.InstallReleaseResponse, error)) {
	fake.installReleaseMutex.Lock()
	defer fake.installReleaseMutex.Unlock()
	fake.InstallReleaseStub = stub
}

func (fake *FakeMyHelmClient) InstallReleaseArgsForCall(i int) (string, string, []helma.InstallOption) {
	fake.installReleaseMutex.RLock()
	defer fake.installReleaseMutex.RUnlock()
	argsForCall := fake.installReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeMyHelmClient) InstallReleaseReturns(result1 *services.InstallReleaseResponse, result2 error) {
	fake.installReleaseMutex.Lock()
	defer fake.installReleaseMutex.Unlock()
	fake.InstallReleaseStub = nil
	fake.installReleaseReturns = struct {
		result1 *services.InstallReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) InstallReleaseReturnsOnCall(i int, result1 *services.InstallReleaseResponse, result2 error) {
	fake.installReleaseMutex.Lock()
	defer fake.installReleaseMutex.Unlock()
	fake.InstallReleaseStub = nil
	if fake.installReleaseReturnsOnCall == nil {
		fake.installReleaseReturnsOnCall = make(map[int]struct {
			result1 *services.InstallReleaseResponse
			result2 error
		})
	}
	fake.installReleaseReturnsOnCall[i] = struct {
		result1 *services.InstallReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) InstallReleaseFromChart(arg1 *chart.Chart, arg2 string, arg3 ...helma.InstallOption) (*services.InstallReleaseResponse, error) {
	fake.installReleaseFromChartMutex.Lock()
	ret, specificReturn := fake.installReleaseFromChartReturnsOnCall[len(fake.installReleaseFromChartArgsForCall)]
	fake.installReleaseFromChartArgsForCall = append(fake.installReleaseFromChartArgsForCall, struct {
		arg1 *chart.Chart
		arg2 string
		arg3 []helma.InstallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("InstallReleaseFromChart", []interface{}{arg1, arg2, arg3})
	fake.installReleaseFromChartMutex.Unlock()
	if fake.InstallReleaseFromChartStub != nil {
		return fake.InstallReleaseFromChartStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.installReleaseFromChartReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMyHelmClient) InstallReleaseFromChartCallCount() int {
	fake.installReleaseFromChartMutex.RLock()
	defer fake.installReleaseFromChartMutex.RUnlock()
	return len(fake.installReleaseFromChartArgsForCall)
}

func (fake *FakeMyHelmClient) InstallReleaseFromChartCalls(stub func(*chart.Chart, string, ...helma.InstallOption) (*services.InstallReleaseResponse, error)) {
	fake.installReleaseFromChartMutex.Lock()
	defer fake.installReleaseFromChartMutex.Unlock()
	fake.InstallReleaseFromChartStub = stub
}

func (fake *FakeMyHelmClient) InstallReleaseFromChartArgsForCall(i int) (*chart.Chart, string, []helma.InstallOption) {
	fake.installReleaseFromChartMutex.RLock()
	defer fake.installReleaseFromChartMutex.RUnlock()
	argsForCall := fake.installReleaseFromChartArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeMyHelmClient) InstallReleaseFromChartReturns(result1 *services.InstallReleaseResponse, result2 error) {
	fake.installReleaseFromChartMutex.Lock()
	defer fake.installReleaseFromChartMutex.Unlock()
	fake.InstallReleaseFromChartStub = nil
	fake.installReleaseFromChartReturns = struct {
		result1 *services.InstallReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) InstallReleaseFromChartReturnsOnCall(i int, result1 *services.InstallReleaseResponse, result2 error) {
	fake.installReleaseFromChartMutex.Lock()
	defer fake.installReleaseFromChartMutex.Unlock()
	fake.InstallReleaseFromChartStub = nil
	if fake.installReleaseFromChartReturnsOnCall == nil {
		fake.installReleaseFromChartReturnsOnCall = make(map[int]struct {
			result1 *services.InstallReleaseResponse
			result2 error
		})
	}
	fake.installReleaseFromChartReturnsOnCall[i] = struct {
		result1 *services.InstallReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) ListReleases(arg1 ...helma.ReleaseListOption) (*services.ListReleasesResponse, error) {
	fake.listReleasesMutex.Lock()
	ret, specificReturn := fake.listReleasesReturnsOnCall[len(fake.listReleasesArgsForCall)]
	fake.listReleasesArgsForCall = append(fake.listReleasesArgsForCall, struct {
		arg1 []helma.ReleaseListOption
	}{arg1})
	fake.recordInvocation("ListReleases", []interface{}{arg1})
	fake.listReleasesMutex.Unlock()
	if fake.ListReleasesStub != nil {
		return fake.ListReleasesStub(arg1...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listReleasesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMyHelmClient) ListReleasesCallCount() int {
	fake.listReleasesMutex.RLock()
	defer fake.listReleasesMutex.RUnlock()
	return len(fake.listReleasesArgsForCall)
}

func (fake *FakeMyHelmClient) ListReleasesCalls(stub func(...helma.ReleaseListOption) (*services.ListReleasesResponse, error)) {
	fake.listReleasesMutex.Lock()
	defer fake.listReleasesMutex.Unlock()
	fake.ListReleasesStub = stub
}

func (fake *FakeMyHelmClient) ListReleasesArgsForCall(i int) []helma.ReleaseListOption {
	fake.listReleasesMutex.RLock()
	defer fake.listReleasesMutex.RUnlock()
	argsForCall := fake.listReleasesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMyHelmClient) ListReleasesReturns(result1 *services.ListReleasesResponse, result2 error) {
	fake.listReleasesMutex.Lock()
	defer fake.listReleasesMutex.Unlock()
	fake.ListReleasesStub = nil
	fake.listReleasesReturns = struct {
		result1 *services.ListReleasesResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) ListReleasesReturnsOnCall(i int, result1 *services.ListReleasesResponse, result2 error) {
	fake.listReleasesMutex.Lock()
	defer fake.listReleasesMutex.Unlock()
	fake.ListReleasesStub = nil
	if fake.listReleasesReturnsOnCall == nil {
		fake.listReleasesReturnsOnCall = make(map[int]struct {
			result1 *services.ListReleasesResponse
			result2 error
		})
	}
	fake.listReleasesReturnsOnCall[i] = struct {
		result1 *services.ListReleasesResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) MergeValueBytes(arg1 []byte, arg2 []byte) ([]byte, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.mergeValueBytesMutex.Lock()
	ret, specificReturn := fake.mergeValueBytesReturnsOnCall[len(fake.mergeValueBytesArgsForCall)]
	fake.mergeValueBytesArgsForCall = append(fake.mergeValueBytesArgsForCall, struct {
		arg1 []byte
		arg2 []byte
	}{arg1Copy, arg2Copy})
	fake.recordInvocation("MergeValueBytes", []interface{}{arg1Copy, arg2Copy})
	fake.mergeValueBytesMutex.Unlock()
	if fake.MergeValueBytesStub != nil {
		return fake.MergeValueBytesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.mergeValueBytesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMyHelmClient) MergeValueBytesCallCount() int {
	fake.mergeValueBytesMutex.RLock()
	defer fake.mergeValueBytesMutex.RUnlock()
	return len(fake.mergeValueBytesArgsForCall)
}

func (fake *FakeMyHelmClient) MergeValueBytesCalls(stub func([]byte, []byte) ([]byte, error)) {
	fake.mergeValueBytesMutex.Lock()
	defer fake.mergeValueBytesMutex.Unlock()
	fake.MergeValueBytesStub = stub
}

func (fake *FakeMyHelmClient) MergeValueBytesArgsForCall(i int) ([]byte, []byte) {
	fake.mergeValueBytesMutex.RLock()
	defer fake.mergeValueBytesMutex.RUnlock()
	argsForCall := fake.mergeValueBytesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMyHelmClient) MergeValueBytesReturns(result1 []byte, result2 error) {
	fake.mergeValueBytesMutex.Lock()
	defer fake.mergeValueBytesMutex.Unlock()
	fake.MergeValueBytesStub = nil
	fake.mergeValueBytesReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) MergeValueBytesReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.mergeValueBytesMutex.Lock()
	defer fake.mergeValueBytesMutex.Unlock()
	fake.MergeValueBytesStub = nil
	if fake.mergeValueBytesReturnsOnCall == nil {
		fake.mergeValueBytesReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.mergeValueBytesReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) PingTiller() error {
	fake.pingTillerMutex.Lock()
	ret, specificReturn := fake.pingTillerReturnsOnCall[len(fake.pingTillerArgsForCall)]
	fake.pingTillerArgsForCall = append(fake.pingTillerArgsForCall, struct {
	}{})
	fake.recordInvocation("PingTiller", []interface{}{})
	fake.pingTillerMutex.Unlock()
	if fake.PingTillerStub != nil {
		return fake.PingTillerStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pingTillerReturns
	return fakeReturns.result1
}

func (fake *FakeMyHelmClient) PingTillerCallCount() int {
	fake.pingTillerMutex.RLock()
	defer fake.pingTillerMutex.RUnlock()
	return len(fake.pingTillerArgsForCall)
}

func (fake *FakeMyHelmClient) PingTillerCalls(stub func() error) {
	fake.pingTillerMutex.Lock()
	defer fake.pingTillerMutex.Unlock()
	fake.PingTillerStub = stub
}

func (fake *FakeMyHelmClient) PingTillerReturns(result1 error) {
	fake.pingTillerMutex.Lock()
	defer fake.pingTillerMutex.Unlock()
	fake.PingTillerStub = nil
	fake.pingTillerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMyHelmClient) PingTillerReturnsOnCall(i int, result1 error) {
	fake.pingTillerMutex.Lock()
	defer fake.pingTillerMutex.Unlock()
	fake.PingTillerStub = nil
	if fake.pingTillerReturnsOnCall == nil {
		fake.pingTillerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pingTillerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMyHelmClient) PrintStatus(arg1 io.Writer, arg2 string) error {
	fake.printStatusMutex.Lock()
	ret, specificReturn := fake.printStatusReturnsOnCall[len(fake.printStatusArgsForCall)]
	fake.printStatusArgsForCall = append(fake.printStatusArgsForCall, struct {
		arg1 io.Writer
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("PrintStatus", []interface{}{arg1, arg2})
	fake.printStatusMutex.Unlock()
	if fake.PrintStatusStub != nil {
		return fake.PrintStatusStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.printStatusReturns
	return fakeReturns.result1
}

func (fake *FakeMyHelmClient) PrintStatusCallCount() int {
	fake.printStatusMutex.RLock()
	defer fake.printStatusMutex.RUnlock()
	return len(fake.printStatusArgsForCall)
}

func (fake *FakeMyHelmClient) PrintStatusCalls(stub func(io.Writer, string) error) {
	fake.printStatusMutex.Lock()
	defer fake.printStatusMutex.Unlock()
	fake.PrintStatusStub = stub
}

func (fake *FakeMyHelmClient) PrintStatusArgsForCall(i int) (io.Writer, string) {
	fake.printStatusMutex.RLock()
	defer fake.printStatusMutex.RUnlock()
	argsForCall := fake.printStatusArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMyHelmClient) PrintStatusReturns(result1 error) {
	fake.printStatusMutex.Lock()
	defer fake.printStatusMutex.Unlock()
	fake.PrintStatusStub = nil
	fake.printStatusReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMyHelmClient) PrintStatusReturnsOnCall(i int, result1 error) {
	fake.printStatusMutex.Lock()
	defer fake.printStatusMutex.Unlock()
	fake.PrintStatusStub = nil
	if fake.printStatusReturnsOnCall == nil {
		fake.printStatusReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.printStatusReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMyHelmClient) ReleaseContent(arg1 string, arg2 ...helma.ContentOption) (*services.GetReleaseContentResponse, error) {
	fake.releaseContentMutex.Lock()
	ret, specificReturn := fake.releaseContentReturnsOnCall[len(fake.releaseContentArgsForCall)]
	fake.releaseContentArgsForCall = append(fake.releaseContentArgsForCall, struct {
		arg1 string
		arg2 []helma.ContentOption
	}{arg1, arg2})
	fake.recordInvocation("ReleaseContent", []interface{}{arg1, arg2})
	fake.releaseContentMutex.Unlock()
	if fake.ReleaseContentStub != nil {
		return fake.ReleaseContentStub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.releaseContentReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMyHelmClient) ReleaseContentCallCount() int {
	fake.releaseContentMutex.RLock()
	defer fake.releaseContentMutex.RUnlock()
	return len(fake.releaseContentArgsForCall)
}

func (fake *FakeMyHelmClient) ReleaseContentCalls(stub func(string, ...helma.ContentOption) (*services.GetReleaseContentResponse, error)) {
	fake.releaseContentMutex.Lock()
	defer fake.releaseContentMutex.Unlock()
	fake.ReleaseContentStub = stub
}

func (fake *FakeMyHelmClient) ReleaseContentArgsForCall(i int) (string, []helma.ContentOption) {
	fake.releaseContentMutex.RLock()
	defer fake.releaseContentMutex.RUnlock()
	argsForCall := fake.releaseContentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMyHelmClient) ReleaseContentReturns(result1 *services.GetReleaseContentResponse, result2 error) {
	fake.releaseContentMutex.Lock()
	defer fake.releaseContentMutex.Unlock()
	fake.ReleaseContentStub = nil
	fake.releaseContentReturns = struct {
		result1 *services.GetReleaseContentResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) ReleaseContentReturnsOnCall(i int, result1 *services.GetReleaseContentResponse, result2 error) {
	fake.releaseContentMutex.Lock()
	defer fake.releaseContentMutex.Unlock()
	fake.ReleaseContentStub = nil
	if fake.releaseContentReturnsOnCall == nil {
		fake.releaseContentReturnsOnCall = make(map[int]struct {
			result1 *services.GetReleaseContentResponse
			result2 error
		})
	}
	fake.releaseContentReturnsOnCall[i] = struct {
		result1 *services.GetReleaseContentResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) ReleaseHistory(arg1 string, arg2 ...helma.HistoryOption) (*services.GetHistoryResponse, error) {
	fake.releaseHistoryMutex.Lock()
	ret, specificReturn := fake.releaseHistoryReturnsOnCall[len(fake.releaseHistoryArgsForCall)]
	fake.releaseHistoryArgsForCall = append(fake.releaseHistoryArgsForCall, struct {
		arg1 string
		arg2 []helma.HistoryOption
	}{arg1, arg2})
	fake.recordInvocation("ReleaseHistory", []interface{}{arg1, arg2})
	fake.releaseHistoryMutex.Unlock()
	if fake.ReleaseHistoryStub != nil {
		return fake.ReleaseHistoryStub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.releaseHistoryReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMyHelmClient) ReleaseHistoryCallCount() int {
	fake.releaseHistoryMutex.RLock()
	defer fake.releaseHistoryMutex.RUnlock()
	return len(fake.releaseHistoryArgsForCall)
}

func (fake *FakeMyHelmClient) ReleaseHistoryCalls(stub func(string, ...helma.HistoryOption) (*services.GetHistoryResponse, error)) {
	fake.releaseHistoryMutex.Lock()
	defer fake.releaseHistoryMutex.Unlock()
	fake.ReleaseHistoryStub = stub
}

func (fake *FakeMyHelmClient) ReleaseHistoryArgsForCall(i int) (string, []helma.HistoryOption) {
	fake.releaseHistoryMutex.RLock()
	defer fake.releaseHistoryMutex.RUnlock()
	argsForCall := fake.releaseHistoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMyHelmClient) ReleaseHistoryReturns(result1 *services.GetHistoryResponse, result2 error) {
	fake.releaseHistoryMutex.Lock()
	defer fake.releaseHistoryMutex.Unlock()
	fake.ReleaseHistoryStub = nil
	fake.releaseHistoryReturns = struct {
		result1 *services.GetHistoryResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) ReleaseHistoryReturnsOnCall(i int, result1 *services.GetHistoryResponse, result2 error) {
	fake.releaseHistoryMutex.Lock()
	defer fake.releaseHistoryMutex.Unlock()
	fake.ReleaseHistoryStub = nil
	if fake.releaseHistoryReturnsOnCall == nil {
		fake.releaseHistoryReturnsOnCall = make(map[int]struct {
			result1 *services.GetHistoryResponse
			result2 error
		})
	}
	fake.releaseHistoryReturnsOnCall[i] = struct {
		result1 *services.GetHistoryResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) ReleaseStatus(arg1 string, arg2 ...helma.StatusOption) (*services.GetReleaseStatusResponse, error) {
	fake.releaseStatusMutex.Lock()
	ret, specificReturn := fake.releaseStatusReturnsOnCall[len(fake.releaseStatusArgsForCall)]
	fake.releaseStatusArgsForCall = append(fake.releaseStatusArgsForCall, struct {
		arg1 string
		arg2 []helma.StatusOption
	}{arg1, arg2})
	fake.recordInvocation("ReleaseStatus", []interface{}{arg1, arg2})
	fake.releaseStatusMutex.Unlock()
	if fake.ReleaseStatusStub != nil {
		return fake.ReleaseStatusStub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.releaseStatusReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMyHelmClient) ReleaseStatusCallCount() int {
	fake.releaseStatusMutex.RLock()
	defer fake.releaseStatusMutex.RUnlock()
	return len(fake.releaseStatusArgsForCall)
}

func (fake *FakeMyHelmClient) ReleaseStatusCalls(stub func(string, ...helma.StatusOption) (*services.GetReleaseStatusResponse, error)) {
	fake.releaseStatusMutex.Lock()
	defer fake.releaseStatusMutex.Unlock()
	fake.ReleaseStatusStub = stub
}

func (fake *FakeMyHelmClient) ReleaseStatusArgsForCall(i int) (string, []helma.StatusOption) {
	fake.releaseStatusMutex.RLock()
	defer fake.releaseStatusMutex.RUnlock()
	argsForCall := fake.releaseStatusArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMyHelmClient) ReleaseStatusReturns(result1 *services.GetReleaseStatusResponse, result2 error) {
	fake.releaseStatusMutex.Lock()
	defer fake.releaseStatusMutex.Unlock()
	fake.ReleaseStatusStub = nil
	fake.releaseStatusReturns = struct {
		result1 *services.GetReleaseStatusResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) ReleaseStatusReturnsOnCall(i int, result1 *services.GetReleaseStatusResponse, result2 error) {
	fake.releaseStatusMutex.Lock()
	defer fake.releaseStatusMutex.Unlock()
	fake.ReleaseStatusStub = nil
	if fake.releaseStatusReturnsOnCall == nil {
		fake.releaseStatusReturnsOnCall = make(map[int]struct {
			result1 *services.GetReleaseStatusResponse
			result2 error
		})
	}
	fake.releaseStatusReturnsOnCall[i] = struct {
		result1 *services.GetReleaseStatusResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) RenderTemplatedValues(arg1 chartutil.ReleaseOptions, arg2 []byte, arg3 chart.Chart) ([]byte, error) {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.renderTemplatedValuesMutex.Lock()
	ret, specificReturn := fake.renderTemplatedValuesReturnsOnCall[len(fake.renderTemplatedValuesArgsForCall)]
	fake.renderTemplatedValuesArgsForCall = append(fake.renderTemplatedValuesArgsForCall, struct {
		arg1 chartutil.ReleaseOptions
		arg2 []byte
		arg3 chart.Chart
	}{arg1, arg2Copy, arg3})
	fake.recordInvocation("RenderTemplatedValues", []interface{}{arg1, arg2Copy, arg3})
	fake.renderTemplatedValuesMutex.Unlock()
	if fake.RenderTemplatedValuesStub != nil {
		return fake.RenderTemplatedValuesStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.renderTemplatedValuesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMyHelmClient) RenderTemplatedValuesCallCount() int {
	fake.renderTemplatedValuesMutex.RLock()
	defer fake.renderTemplatedValuesMutex.RUnlock()
	return len(fake.renderTemplatedValuesArgsForCall)
}

func (fake *FakeMyHelmClient) RenderTemplatedValuesCalls(stub func(chartutil.ReleaseOptions, []byte, chart.Chart) ([]byte, error)) {
	fake.renderTemplatedValuesMutex.Lock()
	defer fake.renderTemplatedValuesMutex.Unlock()
	fake.RenderTemplatedValuesStub = stub
}

func (fake *FakeMyHelmClient) RenderTemplatedValuesArgsForCall(i int) (chartutil.ReleaseOptions, []byte, chart.Chart) {
	fake.renderTemplatedValuesMutex.RLock()
	defer fake.renderTemplatedValuesMutex.RUnlock()
	argsForCall := fake.renderTemplatedValuesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeMyHelmClient) RenderTemplatedValuesReturns(result1 []byte, result2 error) {
	fake.renderTemplatedValuesMutex.Lock()
	defer fake.renderTemplatedValuesMutex.Unlock()
	fake.RenderTemplatedValuesStub = nil
	fake.renderTemplatedValuesReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) RenderTemplatedValuesReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.renderTemplatedValuesMutex.Lock()
	defer fake.renderTemplatedValuesMutex.Unlock()
	fake.RenderTemplatedValuesStub = nil
	if fake.renderTemplatedValuesReturnsOnCall == nil {
		fake.renderTemplatedValuesReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.renderTemplatedValuesReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) ResourceReadiness(arg1 string, arg2 k8s.Cluster) (*string, release.Status_Code, error) {
	fake.resourceReadinessMutex.Lock()
	ret, specificReturn := fake.resourceReadinessReturnsOnCall[len(fake.resourceReadinessArgsForCall)]
	fake.resourceReadinessArgsForCall = append(fake.resourceReadinessArgsForCall, struct {
		arg1 string
		arg2 k8s.Cluster
	}{arg1, arg2})
	fake.recordInvocation("ResourceReadiness", []interface{}{arg1, arg2})
	fake.resourceReadinessMutex.Unlock()
	if fake.ResourceReadinessStub != nil {
		return fake.ResourceReadinessStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.resourceReadinessReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeMyHelmClient) ResourceReadinessCallCount() int {
	fake.resourceReadinessMutex.RLock()
	defer fake.resourceReadinessMutex.RUnlock()
	return len(fake.resourceReadinessArgsForCall)
}

func (fake *FakeMyHelmClient) ResourceReadinessCalls(stub func(string, k8s.Cluster) (*string, release.Status_Code, error)) {
	fake.resourceReadinessMutex.Lock()
	defer fake.resourceReadinessMutex.Unlock()
	fake.ResourceReadinessStub = stub
}

func (fake *FakeMyHelmClient) ResourceReadinessArgsForCall(i int) (string, k8s.Cluster) {
	fake.resourceReadinessMutex.RLock()
	defer fake.resourceReadinessMutex.RUnlock()
	argsForCall := fake.resourceReadinessArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMyHelmClient) ResourceReadinessReturns(result1 *string, result2 release.Status_Code, result3 error) {
	fake.resourceReadinessMutex.Lock()
	defer fake.resourceReadinessMutex.Unlock()
	fake.ResourceReadinessStub = nil
	fake.resourceReadinessReturns = struct {
		result1 *string
		result2 release.Status_Code
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeMyHelmClient) ResourceReadinessReturnsOnCall(i int, result1 *string, result2 release.Status_Code, result3 error) {
	fake.resourceReadinessMutex.Lock()
	defer fake.resourceReadinessMutex.Unlock()
	fake.ResourceReadinessStub = nil
	if fake.resourceReadinessReturnsOnCall == nil {
		fake.resourceReadinessReturnsOnCall = make(map[int]struct {
			result1 *string
			result2 release.Status_Code
			result3 error
		})
	}
	fake.resourceReadinessReturnsOnCall[i] = struct {
		result1 *string
		result2 release.Status_Code
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeMyHelmClient) RollbackRelease(arg1 string, arg2 ...helma.RollbackOption) (*services.RollbackReleaseResponse, error) {
	fake.rollbackReleaseMutex.Lock()
	ret, specificReturn := fake.rollbackReleaseReturnsOnCall[len(fake.rollbackReleaseArgsForCall)]
	fake.rollbackReleaseArgsForCall = append(fake.rollbackReleaseArgsForCall, struct {
		arg1 string
		arg2 []helma.RollbackOption
	}{arg1, arg2})
	fake.recordInvocation("RollbackRelease", []interface{}{arg1, arg2})
	fake.rollbackReleaseMutex.Unlock()
	if fake.RollbackReleaseStub != nil {
		return fake.RollbackReleaseStub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.rollbackReleaseReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMyHelmClient) RollbackReleaseCallCount() int {
	fake.rollbackReleaseMutex.RLock()
	defer fake.rollbackReleaseMutex.RUnlock()
	return len(fake.rollbackReleaseArgsForCall)
}

func (fake *FakeMyHelmClient) RollbackReleaseCalls(stub func(string, ...helma.RollbackOption) (*services.RollbackReleaseResponse, error)) {
	fake.rollbackReleaseMutex.Lock()
	defer fake.rollbackReleaseMutex.Unlock()
	fake.RollbackReleaseStub = stub
}

func (fake *FakeMyHelmClient) RollbackReleaseArgsForCall(i int) (string, []helma.RollbackOption) {
	fake.rollbackReleaseMutex.RLock()
	defer fake.rollbackReleaseMutex.RUnlock()
	argsForCall := fake.rollbackReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMyHelmClient) RollbackReleaseReturns(result1 *services.RollbackReleaseResponse, result2 error) {
	fake.rollbackReleaseMutex.Lock()
	defer fake.rollbackReleaseMutex.Unlock()
	fake.RollbackReleaseStub = nil
	fake.rollbackReleaseReturns = struct {
		result1 *services.RollbackReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) RollbackReleaseReturnsOnCall(i int, result1 *services.RollbackReleaseResponse, result2 error) {
	fake.rollbackReleaseMutex.Lock()
	defer fake.rollbackReleaseMutex.Unlock()
	fake.RollbackReleaseStub = nil
	if fake.rollbackReleaseReturnsOnCall == nil {
		fake.rollbackReleaseReturnsOnCall = make(map[int]struct {
			result1 *services.RollbackReleaseResponse
			result2 error
		})
	}
	fake.rollbackReleaseReturnsOnCall[i] = struct {
		result1 *services.RollbackReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) RunReleaseTest(arg1 string, arg2 ...helma.ReleaseTestOption) (<-chan *services.TestReleaseResponse, <-chan error) {
	fake.runReleaseTestMutex.Lock()
	ret, specificReturn := fake.runReleaseTestReturnsOnCall[len(fake.runReleaseTestArgsForCall)]
	fake.runReleaseTestArgsForCall = append(fake.runReleaseTestArgsForCall, struct {
		arg1 string
		arg2 []helma.ReleaseTestOption
	}{arg1, arg2})
	fake.recordInvocation("RunReleaseTest", []interface{}{arg1, arg2})
	fake.runReleaseTestMutex.Unlock()
	if fake.RunReleaseTestStub != nil {
		return fake.RunReleaseTestStub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.runReleaseTestReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMyHelmClient) RunReleaseTestCallCount() int {
	fake.runReleaseTestMutex.RLock()
	defer fake.runReleaseTestMutex.RUnlock()
	return len(fake.runReleaseTestArgsForCall)
}

func (fake *FakeMyHelmClient) RunReleaseTestCalls(stub func(string, ...helma.ReleaseTestOption) (<-chan *services.TestReleaseResponse, <-chan error)) {
	fake.runReleaseTestMutex.Lock()
	defer fake.runReleaseTestMutex.Unlock()
	fake.RunReleaseTestStub = stub
}

func (fake *FakeMyHelmClient) RunReleaseTestArgsForCall(i int) (string, []helma.ReleaseTestOption) {
	fake.runReleaseTestMutex.RLock()
	defer fake.runReleaseTestMutex.RUnlock()
	argsForCall := fake.runReleaseTestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMyHelmClient) RunReleaseTestReturns(result1 <-chan *services.TestReleaseResponse, result2 <-chan error) {
	fake.runReleaseTestMutex.Lock()
	defer fake.runReleaseTestMutex.Unlock()
	fake.RunReleaseTestStub = nil
	fake.runReleaseTestReturns = struct {
		result1 <-chan *services.TestReleaseResponse
		result2 <-chan error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) RunReleaseTestReturnsOnCall(i int, result1 <-chan *services.TestReleaseResponse, result2 <-chan error) {
	fake.runReleaseTestMutex.Lock()
	defer fake.runReleaseTestMutex.Unlock()
	fake.RunReleaseTestStub = nil
	if fake.runReleaseTestReturnsOnCall == nil {
		fake.runReleaseTestReturnsOnCall = make(map[int]struct {
			result1 <-chan *services.TestReleaseResponse
			result2 <-chan error
		})
	}
	fake.runReleaseTestReturnsOnCall[i] = struct {
		result1 <-chan *services.TestReleaseResponse
		result2 <-chan error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) Uninstall(arg1 *installer.Options) error {
	fake.uninstallMutex.Lock()
	ret, specificReturn := fake.uninstallReturnsOnCall[len(fake.uninstallArgsForCall)]
	fake.uninstallArgsForCall = append(fake.uninstallArgsForCall, struct {
		arg1 *installer.Options
	}{arg1})
	fake.recordInvocation("Uninstall", []interface{}{arg1})
	fake.uninstallMutex.Unlock()
	if fake.UninstallStub != nil {
		return fake.UninstallStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.uninstallReturns
	return fakeReturns.result1
}

func (fake *FakeMyHelmClient) UninstallCallCount() int {
	fake.uninstallMutex.RLock()
	defer fake.uninstallMutex.RUnlock()
	return len(fake.uninstallArgsForCall)
}

func (fake *FakeMyHelmClient) UninstallCalls(stub func(*installer.Options) error) {
	fake.uninstallMutex.Lock()
	defer fake.uninstallMutex.Unlock()
	fake.UninstallStub = stub
}

func (fake *FakeMyHelmClient) UninstallArgsForCall(i int) *installer.Options {
	fake.uninstallMutex.RLock()
	defer fake.uninstallMutex.RUnlock()
	argsForCall := fake.uninstallArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMyHelmClient) UninstallReturns(result1 error) {
	fake.uninstallMutex.Lock()
	defer fake.uninstallMutex.Unlock()
	fake.UninstallStub = nil
	fake.uninstallReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMyHelmClient) UninstallReturnsOnCall(i int, result1 error) {
	fake.uninstallMutex.Lock()
	defer fake.uninstallMutex.Unlock()
	fake.UninstallStub = nil
	if fake.uninstallReturnsOnCall == nil {
		fake.uninstallReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uninstallReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMyHelmClient) UpdateChart(arg1 *helm.MyChart, arg2 string, arg3 string, arg4 []byte) (*services.UpdateReleaseResponse, error) {
	var arg4Copy []byte
	if arg4 != nil {
		arg4Copy = make([]byte, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.updateChartMutex.Lock()
	ret, specificReturn := fake.updateChartReturnsOnCall[len(fake.updateChartArgsForCall)]
	fake.updateChartArgsForCall = append(fake.updateChartArgsForCall, struct {
		arg1 *helm.MyChart
		arg2 string
		arg3 string
		arg4 []byte
	}{arg1, arg2, arg3, arg4Copy})
	fake.recordInvocation("UpdateChart", []interface{}{arg1, arg2, arg3, arg4Copy})
	fake.updateChartMutex.Unlock()
	if fake.UpdateChartStub != nil {
		return fake.UpdateChartStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateChartReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMyHelmClient) UpdateChartCallCount() int {
	fake.updateChartMutex.RLock()
	defer fake.updateChartMutex.RUnlock()
	return len(fake.updateChartArgsForCall)
}

func (fake *FakeMyHelmClient) UpdateChartCalls(stub func(*helm.MyChart, string, string, []byte) (*services.UpdateReleaseResponse, error)) {
	fake.updateChartMutex.Lock()
	defer fake.updateChartMutex.Unlock()
	fake.UpdateChartStub = stub
}

func (fake *FakeMyHelmClient) UpdateChartArgsForCall(i int) (*helm.MyChart, string, string, []byte) {
	fake.updateChartMutex.RLock()
	defer fake.updateChartMutex.RUnlock()
	argsForCall := fake.updateChartArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeMyHelmClient) UpdateChartReturns(result1 *services.UpdateReleaseResponse, result2 error) {
	fake.updateChartMutex.Lock()
	defer fake.updateChartMutex.Unlock()
	fake.UpdateChartStub = nil
	fake.updateChartReturns = struct {
		result1 *services.UpdateReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) UpdateChartReturnsOnCall(i int, result1 *services.UpdateReleaseResponse, result2 error) {
	fake.updateChartMutex.Lock()
	defer fake.updateChartMutex.Unlock()
	fake.UpdateChartStub = nil
	if fake.updateChartReturnsOnCall == nil {
		fake.updateChartReturnsOnCall = make(map[int]struct {
			result1 *services.UpdateReleaseResponse
			result2 error
		})
	}
	fake.updateChartReturnsOnCall[i] = struct {
		result1 *services.UpdateReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) UpdateRelease(arg1 string, arg2 string, arg3 ...helma.UpdateOption) (*services.UpdateReleaseResponse, error) {
	fake.updateReleaseMutex.Lock()
	ret, specificReturn := fake.updateReleaseReturnsOnCall[len(fake.updateReleaseArgsForCall)]
	fake.updateReleaseArgsForCall = append(fake.updateReleaseArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []helma.UpdateOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("UpdateRelease", []interface{}{arg1, arg2, arg3})
	fake.updateReleaseMutex.Unlock()
	if fake.UpdateReleaseStub != nil {
		return fake.UpdateReleaseStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateReleaseReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMyHelmClient) UpdateReleaseCallCount() int {
	fake.updateReleaseMutex.RLock()
	defer fake.updateReleaseMutex.RUnlock()
	return len(fake.updateReleaseArgsForCall)
}

func (fake *FakeMyHelmClient) UpdateReleaseCalls(stub func(string, string, ...helma.UpdateOption) (*services.UpdateReleaseResponse, error)) {
	fake.updateReleaseMutex.Lock()
	defer fake.updateReleaseMutex.Unlock()
	fake.UpdateReleaseStub = stub
}

func (fake *FakeMyHelmClient) UpdateReleaseArgsForCall(i int) (string, string, []helma.UpdateOption) {
	fake.updateReleaseMutex.RLock()
	defer fake.updateReleaseMutex.RUnlock()
	argsForCall := fake.updateReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeMyHelmClient) UpdateReleaseReturns(result1 *services.UpdateReleaseResponse, result2 error) {
	fake.updateReleaseMutex.Lock()
	defer fake.updateReleaseMutex.Unlock()
	fake.UpdateReleaseStub = nil
	fake.updateReleaseReturns = struct {
		result1 *services.UpdateReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) UpdateReleaseReturnsOnCall(i int, result1 *services.UpdateReleaseResponse, result2 error) {
	fake.updateReleaseMutex.Lock()
	defer fake.updateReleaseMutex.Unlock()
	fake.UpdateReleaseStub = nil
	if fake.updateReleaseReturnsOnCall == nil {
		fake.updateReleaseReturnsOnCall = make(map[int]struct {
			result1 *services.UpdateReleaseResponse
			result2 error
		})
	}
	fake.updateReleaseReturnsOnCall[i] = struct {
		result1 *services.UpdateReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) UpdateReleaseFromChart(arg1 string, arg2 *chart.Chart, arg3 ...helma.UpdateOption) (*services.UpdateReleaseResponse, error) {
	fake.updateReleaseFromChartMutex.Lock()
	ret, specificReturn := fake.updateReleaseFromChartReturnsOnCall[len(fake.updateReleaseFromChartArgsForCall)]
	fake.updateReleaseFromChartArgsForCall = append(fake.updateReleaseFromChartArgsForCall, struct {
		arg1 string
		arg2 *chart.Chart
		arg3 []helma.UpdateOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("UpdateReleaseFromChart", []interface{}{arg1, arg2, arg3})
	fake.updateReleaseFromChartMutex.Unlock()
	if fake.UpdateReleaseFromChartStub != nil {
		return fake.UpdateReleaseFromChartStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateReleaseFromChartReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMyHelmClient) UpdateReleaseFromChartCallCount() int {
	fake.updateReleaseFromChartMutex.RLock()
	defer fake.updateReleaseFromChartMutex.RUnlock()
	return len(fake.updateReleaseFromChartArgsForCall)
}

func (fake *FakeMyHelmClient) UpdateReleaseFromChartCalls(stub func(string, *chart.Chart, ...helma.UpdateOption) (*services.UpdateReleaseResponse, error)) {
	fake.updateReleaseFromChartMutex.Lock()
	defer fake.updateReleaseFromChartMutex.Unlock()
	fake.UpdateReleaseFromChartStub = stub
}

func (fake *FakeMyHelmClient) UpdateReleaseFromChartArgsForCall(i int) (string, *chart.Chart, []helma.UpdateOption) {
	fake.updateReleaseFromChartMutex.RLock()
	defer fake.updateReleaseFromChartMutex.RUnlock()
	argsForCall := fake.updateReleaseFromChartArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeMyHelmClient) UpdateReleaseFromChartReturns(result1 *services.UpdateReleaseResponse, result2 error) {
	fake.updateReleaseFromChartMutex.Lock()
	defer fake.updateReleaseFromChartMutex.Unlock()
	fake.UpdateReleaseFromChartStub = nil
	fake.updateReleaseFromChartReturns = struct {
		result1 *services.UpdateReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) UpdateReleaseFromChartReturnsOnCall(i int, result1 *services.UpdateReleaseResponse, result2 error) {
	fake.updateReleaseFromChartMutex.Lock()
	defer fake.updateReleaseFromChartMutex.Unlock()
	fake.UpdateReleaseFromChartStub = nil
	if fake.updateReleaseFromChartReturnsOnCall == nil {
		fake.updateReleaseFromChartReturnsOnCall = make(map[int]struct {
			result1 *services.UpdateReleaseResponse
			result2 error
		})
	}
	fake.updateReleaseFromChartReturnsOnCall[i] = struct {
		result1 *services.UpdateReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeMyHelmClient) Upgrade(arg1 *installer.Options) error {
	fake.upgradeMutex.Lock()
	ret, specificReturn := fake.upgradeReturnsOnCall[len(fake.upgradeArgsForCall)]
	fake.upgradeArgsForCall = append(fake.upgradeArgsForCall, struct {
		arg1 *installer.Options
	}{arg1})
	fake.recordInvocation("Upgrade", []interface{}{arg1})
	fake.upgradeMutex.Unlock()
	if fake.UpgradeStub != nil {
		return fake.UpgradeStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.upgradeReturns
	return fakeReturns.result1
}

func (fake *FakeMyHelmClient) UpgradeCallCount() int {
	fake.upgradeMutex.RLock()
	defer fake.upgradeMutex.RUnlock()
	return len(fake.upgradeArgsForCall)
}

func (fake *FakeMyHelmClient) UpgradeCalls(stub func(*installer.Options) error) {
	fake.upgradeMutex.Lock()
	defer fake.upgradeMutex.Unlock()
	fake.UpgradeStub = stub
}

func (fake *FakeMyHelmClient) UpgradeArgsForCall(i int) *installer.Options {
	fake.upgradeMutex.RLock()
	defer fake.upgradeMutex.RUnlock()
	argsForCall := fake.upgradeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMyHelmClient) UpgradeReturns(result1 error) {
	fake.upgradeMutex.Lock()
	defer fake.upgradeMutex.Unlock()
	fake.UpgradeStub = nil
	fake.upgradeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMyHelmClient) UpgradeReturnsOnCall(i int, result1 error) {
	fake.upgradeMutex.Lock()
	defer fake.upgradeMutex.Unlock()
	fake.UpgradeStub = nil
	if fake.upgradeReturnsOnCall == nil {
		fake.upgradeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.upgradeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMyHelmClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.deleteReleaseMutex.RLock()
	defer fake.deleteReleaseMutex.RUnlock()
	fake.getVersionMutex.RLock()
	defer fake.getVersionMutex.RUnlock()
	fake.hasDifferentTLSConfigMutex.RLock()
	defer fake.hasDifferentTLSConfigMutex.RUnlock()
	fake.installMutex.RLock()
	defer fake.installMutex.RUnlock()
	fake.installChartMutex.RLock()
	defer fake.installChartMutex.RUnlock()
	fake.installOperatorMutex.RLock()
	defer fake.installOperatorMutex.RUnlock()
	fake.installReleaseMutex.RLock()
	defer fake.installReleaseMutex.RUnlock()
	fake.installReleaseFromChartMutex.RLock()
	defer fake.installReleaseFromChartMutex.RUnlock()
	fake.listReleasesMutex.RLock()
	defer fake.listReleasesMutex.RUnlock()
	fake.mergeValueBytesMutex.RLock()
	defer fake.mergeValueBytesMutex.RUnlock()
	fake.pingTillerMutex.RLock()
	defer fake.pingTillerMutex.RUnlock()
	fake.printStatusMutex.RLock()
	defer fake.printStatusMutex.RUnlock()
	fake.releaseContentMutex.RLock()
	defer fake.releaseContentMutex.RUnlock()
	fake.releaseHistoryMutex.RLock()
	defer fake.releaseHistoryMutex.RUnlock()
	fake.releaseStatusMutex.RLock()
	defer fake.releaseStatusMutex.RUnlock()
	fake.renderTemplatedValuesMutex.RLock()
	defer fake.renderTemplatedValuesMutex.RUnlock()
	fake.resourceReadinessMutex.RLock()
	defer fake.resourceReadinessMutex.RUnlock()
	fake.rollbackReleaseMutex.RLock()
	defer fake.rollbackReleaseMutex.RUnlock()
	fake.runReleaseTestMutex.RLock()
	defer fake.runReleaseTestMutex.RUnlock()
	fake.uninstallMutex.RLock()
	defer fake.uninstallMutex.RUnlock()
	fake.updateChartMutex.RLock()
	defer fake.updateChartMutex.RUnlock()
	fake.updateReleaseMutex.RLock()
	defer fake.updateReleaseMutex.RUnlock()
	fake.updateReleaseFromChartMutex.RLock()
	defer fake.updateReleaseFromChartMutex.RUnlock()
	fake.upgradeMutex.RLock()
	defer fake.upgradeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeMyHelmClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ helm.MyHelmClient = new(FakeMyHelmClient)
